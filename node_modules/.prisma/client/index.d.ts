
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model User
 * 
 */
export type User = {
  id: number
  createdAt: Date
  updatedAt: Date
  firstname: string
  lastname: string
  email: string
  avatarS3Key: string
  coverPicS3Key: string
}

/**
 * Model Post
 * 
 */
export type Post = {
  id: number
  createdAt: Date
  updatedAt: Date
  htmlContent: string
  userId: number
}

/**
 * Model PostLike
 * 
 */
export type PostLike = {
  id: number
  createdAt: Date
  updatedAt: Date
  userId: number
  postId: number
}

/**
 * Model PostComment
 * 
 */
export type PostComment = {
  id: number
  createdAt: Date
  updatedAt: Date
  userId: number
  postId: number
  text: string
}

/**
 * Model PostAttachment
 * 
 */
export type PostAttachment = {
  id: number
  type: DocumentType
  s3Key: string
}

/**
 * Model Friendship
 * 
 */
export type Friendship = {
  id: number
  createdAt: Date
  updatedAt: Date
  status: FriendshipStatus
  fromId: number
  toId: number
}

/**
 * Model Conversation
 * 
 */
export type Conversation = {
  id: number
  createdAt: Date
  updatedAt: Date
  fromId: number
  toId: number | null
}

/**
 * Model ConversationMessage
 * 
 */
export type ConversationMessage = {
  id: number
  createdAt: Date
  updatedAt: Date
  conversationId: number | null
  userId: number
}

/**
 * Model Notification
 * 
 */
export type Notification = {
  id: number
  createdAt: Date
  updatedAt: Date
  read: boolean
  friendshipId: number | null
  conversationMessageId: number | null
}


/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export const DocumentType: {
  PICTURE: 'PICTURE',
  SOUND: 'SOUND',
  VIDEO: 'VIDEO'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


export const FriendshipStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  IGNORED: 'IGNORED'
};

export type FriendshipStatus = (typeof FriendshipStatus)[keyof typeof FriendshipStatus]


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>;

  $transaction<R>(fn: (prisma: Prisma.TransactionClient) => Promise<R>, options?: {maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel}): Promise<R>;

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<GlobalReject>;

  /**
   * `prisma.postLike`: Exposes CRUD operations for the **PostLike** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostLikes
    * const postLikes = await prisma.postLike.findMany()
    * ```
    */
  get postLike(): Prisma.PostLikeDelegate<GlobalReject>;

  /**
   * `prisma.postComment`: Exposes CRUD operations for the **PostComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostComments
    * const postComments = await prisma.postComment.findMany()
    * ```
    */
  get postComment(): Prisma.PostCommentDelegate<GlobalReject>;

  /**
   * `prisma.postAttachment`: Exposes CRUD operations for the **PostAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostAttachments
    * const postAttachments = await prisma.postAttachment.findMany()
    * ```
    */
  get postAttachment(): Prisma.PostAttachmentDelegate<GlobalReject>;

  /**
   * `prisma.friendship`: Exposes CRUD operations for the **Friendship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Friendships
    * const friendships = await prisma.friendship.findMany()
    * ```
    */
  get friendship(): Prisma.FriendshipDelegate<GlobalReject>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **Conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.ConversationDelegate<GlobalReject>;

  /**
   * `prisma.conversationMessage`: Exposes CRUD operations for the **ConversationMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConversationMessages
    * const conversationMessages = await prisma.conversationMessage.findMany()
    * ```
    */
  get conversationMessage(): Prisma.ConversationMessageDelegate<GlobalReject>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.7.1
   * Query Engine version: 272861e07ab64f234d3ffc4094e32bd61775599c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    User: 'User',
    Post: 'Post',
    PostLike: 'PostLike',
    PostComment: 'PostComment',
    PostAttachment: 'PostAttachment',
    Friendship: 'Friendship',
    Conversation: 'Conversation',
    ConversationMessage: 'ConversationMessage',
    Notification: 'Notification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<PrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    Posts: number
    PostLikes: number
    PostComment: number
    FromFriendship: number
    ToFrienship: number
    BlockedUsers: number
    BlockedByUsers: number
    ConversationsSent: number
    ConversationsReceived: number
    ConversationMessages: number
  }

  export type UserCountOutputTypeSelect = {
    Posts?: boolean
    PostLikes?: boolean
    PostComment?: boolean
    FromFriendship?: boolean
    ToFrienship?: boolean
    BlockedUsers?: boolean
    BlockedByUsers?: boolean
    ConversationsSent?: boolean
    ConversationsReceived?: boolean
    ConversationMessages?: boolean
  }

  export type UserCountOutputTypeGetPayload<S extends boolean | null | undefined | UserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UserCountOutputTypeArgs)
    ? UserCountOutputType 
    : S extends { select: any } & (UserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
      : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     * 
    **/
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type PostCountOutputType
   */


  export type PostCountOutputType = {
    PostLikes: number
    PostComments: number
  }

  export type PostCountOutputTypeSelect = {
    PostLikes?: boolean
    PostComments?: boolean
  }

  export type PostCountOutputTypeGetPayload<S extends boolean | null | undefined | PostCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PostCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (PostCountOutputTypeArgs)
    ? PostCountOutputType 
    : S extends { select: any } & (PostCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof PostCountOutputType ? PostCountOutputType[P] : never
  } 
      : PostCountOutputType




  // Custom InputTypes

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PostCountOutputType
     * 
    **/
    select?: PostCountOutputTypeSelect | null
  }



  /**
   * Count Type FriendshipCountOutputType
   */


  export type FriendshipCountOutputType = {
    Notification: number
  }

  export type FriendshipCountOutputTypeSelect = {
    Notification?: boolean
  }

  export type FriendshipCountOutputTypeGetPayload<S extends boolean | null | undefined | FriendshipCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? FriendshipCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (FriendshipCountOutputTypeArgs)
    ? FriendshipCountOutputType 
    : S extends { select: any } & (FriendshipCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof FriendshipCountOutputType ? FriendshipCountOutputType[P] : never
  } 
      : FriendshipCountOutputType




  // Custom InputTypes

  /**
   * FriendshipCountOutputType without action
   */
  export type FriendshipCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FriendshipCountOutputType
     * 
    **/
    select?: FriendshipCountOutputTypeSelect | null
  }



  /**
   * Count Type ConversationCountOutputType
   */


  export type ConversationCountOutputType = {
    Messages: number
  }

  export type ConversationCountOutputTypeSelect = {
    Messages?: boolean
  }

  export type ConversationCountOutputTypeGetPayload<S extends boolean | null | undefined | ConversationCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ConversationCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ConversationCountOutputTypeArgs)
    ? ConversationCountOutputType 
    : S extends { select: any } & (ConversationCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ConversationCountOutputType ? ConversationCountOutputType[P] : never
  } 
      : ConversationCountOutputType




  // Custom InputTypes

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ConversationCountOutputType
     * 
    **/
    select?: ConversationCountOutputTypeSelect | null
  }



  /**
   * Count Type ConversationMessageCountOutputType
   */


  export type ConversationMessageCountOutputType = {
    Notification: number
  }

  export type ConversationMessageCountOutputTypeSelect = {
    Notification?: boolean
  }

  export type ConversationMessageCountOutputTypeGetPayload<S extends boolean | null | undefined | ConversationMessageCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ConversationMessageCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ConversationMessageCountOutputTypeArgs)
    ? ConversationMessageCountOutputType 
    : S extends { select: any } & (ConversationMessageCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ConversationMessageCountOutputType ? ConversationMessageCountOutputType[P] : never
  } 
      : ConversationMessageCountOutputType




  // Custom InputTypes

  /**
   * ConversationMessageCountOutputType without action
   */
  export type ConversationMessageCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ConversationMessageCountOutputType
     * 
    **/
    select?: ConversationMessageCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    firstname: string | null
    lastname: string | null
    email: string | null
    avatarS3Key: string | null
    coverPicS3Key: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    firstname: string | null
    lastname: string | null
    email: string | null
    avatarS3Key: string | null
    coverPicS3Key: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    firstname: number
    lastname: number
    email: number
    avatarS3Key: number
    coverPicS3Key: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    firstname?: true
    lastname?: true
    email?: true
    avatarS3Key?: true
    coverPicS3Key?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    firstname?: true
    lastname?: true
    email?: true
    avatarS3Key?: true
    coverPicS3Key?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    firstname?: true
    lastname?: true
    email?: true
    avatarS3Key?: true
    coverPicS3Key?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: Array<UserScalarFieldEnum>
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    firstname: string
    lastname: string
    email: string
    avatarS3Key: string
    coverPicS3Key: string
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    avatarS3Key?: boolean
    coverPicS3Key?: boolean
    Posts?: boolean | PostFindManyArgs
    PostLikes?: boolean | PostLikeFindManyArgs
    PostComment?: boolean | PostCommentFindManyArgs
    FromFriendship?: boolean | FriendshipFindManyArgs
    ToFrienship?: boolean | FriendshipFindManyArgs
    BlockedUsers?: boolean | UserFindManyArgs
    BlockedByUsers?: boolean | UserFindManyArgs
    ConversationsSent?: boolean | ConversationFindManyArgs
    ConversationsReceived?: boolean | ConversationFindManyArgs
    ConversationMessages?: boolean | ConversationMessageFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  }


  export type UserInclude = {
    Posts?: boolean | PostFindManyArgs
    PostLikes?: boolean | PostLikeFindManyArgs
    PostComment?: boolean | PostCommentFindManyArgs
    FromFriendship?: boolean | FriendshipFindManyArgs
    ToFrienship?: boolean | FriendshipFindManyArgs
    BlockedUsers?: boolean | UserFindManyArgs
    BlockedByUsers?: boolean | UserFindManyArgs
    ConversationsSent?: boolean | ConversationFindManyArgs
    ConversationsReceived?: boolean | ConversationFindManyArgs
    ConversationMessages?: boolean | ConversationMessageFindManyArgs
    _count?: boolean | UserCountOutputTypeArgs
  } 

  export type UserGetPayload<S extends boolean | null | undefined | UserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? User :
    S extends undefined ? never :
    S extends { include: any } & (UserArgs | UserFindManyArgs)
    ? User  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Posts' ? Array < PostGetPayload<S['include'][P]>>  :
        P extends 'PostLikes' ? Array < PostLikeGetPayload<S['include'][P]>>  :
        P extends 'PostComment' ? Array < PostCommentGetPayload<S['include'][P]>>  :
        P extends 'FromFriendship' ? Array < FriendshipGetPayload<S['include'][P]>>  :
        P extends 'ToFrienship' ? Array < FriendshipGetPayload<S['include'][P]>>  :
        P extends 'BlockedUsers' ? Array < UserGetPayload<S['include'][P]>>  :
        P extends 'BlockedByUsers' ? Array < UserGetPayload<S['include'][P]>>  :
        P extends 'ConversationsSent' ? Array < ConversationGetPayload<S['include'][P]>>  :
        P extends 'ConversationsReceived' ? Array < ConversationGetPayload<S['include'][P]>>  :
        P extends 'ConversationMessages' ? Array < ConversationMessageGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserArgs | UserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Posts' ? Array < PostGetPayload<S['select'][P]>>  :
        P extends 'PostLikes' ? Array < PostLikeGetPayload<S['select'][P]>>  :
        P extends 'PostComment' ? Array < PostCommentGetPayload<S['select'][P]>>  :
        P extends 'FromFriendship' ? Array < FriendshipGetPayload<S['select'][P]>>  :
        P extends 'ToFrienship' ? Array < FriendshipGetPayload<S['select'][P]>>  :
        P extends 'BlockedUsers' ? Array < UserGetPayload<S['select'][P]>>  :
        P extends 'BlockedByUsers' ? Array < UserGetPayload<S['select'][P]>>  :
        P extends 'ConversationsSent' ? Array < ConversationGetPayload<S['select'][P]>>  :
        P extends 'ConversationsReceived' ? Array < ConversationGetPayload<S['select'][P]>>  :
        P extends 'ConversationMessages' ? Array < ConversationMessageGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
      : User


  type UserCountArgs = Merge<
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }
  >

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): PrismaPromise<Array<UserGetPayload<T>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Posts<T extends PostFindManyArgs= {}>(args?: Subset<T, PostFindManyArgs>): PrismaPromise<Array<PostGetPayload<T>>| Null>;

    PostLikes<T extends PostLikeFindManyArgs= {}>(args?: Subset<T, PostLikeFindManyArgs>): PrismaPromise<Array<PostLikeGetPayload<T>>| Null>;

    PostComment<T extends PostCommentFindManyArgs= {}>(args?: Subset<T, PostCommentFindManyArgs>): PrismaPromise<Array<PostCommentGetPayload<T>>| Null>;

    FromFriendship<T extends FriendshipFindManyArgs= {}>(args?: Subset<T, FriendshipFindManyArgs>): PrismaPromise<Array<FriendshipGetPayload<T>>| Null>;

    ToFrienship<T extends FriendshipFindManyArgs= {}>(args?: Subset<T, FriendshipFindManyArgs>): PrismaPromise<Array<FriendshipGetPayload<T>>| Null>;

    BlockedUsers<T extends UserFindManyArgs= {}>(args?: Subset<T, UserFindManyArgs>): PrismaPromise<Array<UserGetPayload<T>>| Null>;

    BlockedByUsers<T extends UserFindManyArgs= {}>(args?: Subset<T, UserFindManyArgs>): PrismaPromise<Array<UserGetPayload<T>>| Null>;

    ConversationsSent<T extends ConversationFindManyArgs= {}>(args?: Subset<T, ConversationFindManyArgs>): PrismaPromise<Array<ConversationGetPayload<T>>| Null>;

    ConversationsReceived<T extends ConversationFindManyArgs= {}>(args?: Subset<T, ConversationFindManyArgs>): PrismaPromise<Array<ConversationGetPayload<T>>| Null>;

    ConversationMessages<T extends ConversationMessageFindManyArgs= {}>(args?: Subset<T, ConversationMessageFindManyArgs>): PrismaPromise<Array<ConversationMessageGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }

  /**
   * User: findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User: findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     * 
    **/
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     * 
    **/
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     * 
    **/
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     * 
    **/
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     * 
    **/
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     * 
    **/
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     * 
    **/
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     * 
    **/
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     * 
    **/
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     * 
    **/
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     * 
    **/
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     * 
    **/
    where?: UserWhereInput
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     * 
    **/
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UserInclude | null
  }



  /**
   * Model Post
   */


  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PostSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PostMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    htmlContent: string | null
    userId: number | null
  }

  export type PostMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    htmlContent: string | null
    userId: number | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    htmlContent: number
    userId: number
    _all: number
  }


  export type PostAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PostSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PostMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    htmlContent?: true
    userId?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    htmlContent?: true
    userId?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    htmlContent?: true
    userId?: true
    _all?: true
  }

  export type PostAggregateArgs = {
    /**
     * Filter which Post to aggregate.
     * 
    **/
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     * 
    **/
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs = {
    where?: PostWhereInput
    orderBy?: Enumerable<PostOrderByWithAggregationInput>
    by: Array<PostScalarFieldEnum>
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _avg?: PostAvgAggregateInputType
    _sum?: PostSumAggregateInputType
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }


  export type PostGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    htmlContent: string
    userId: number
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    htmlContent?: boolean
    User?: boolean | UserArgs
    userId?: boolean
    PostLikes?: boolean | PostLikeFindManyArgs
    PostComments?: boolean | PostCommentFindManyArgs
    _count?: boolean | PostCountOutputTypeArgs
  }


  export type PostInclude = {
    User?: boolean | UserArgs
    PostLikes?: boolean | PostLikeFindManyArgs
    PostComments?: boolean | PostCommentFindManyArgs
    _count?: boolean | PostCountOutputTypeArgs
  } 

  export type PostGetPayload<S extends boolean | null | undefined | PostArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Post :
    S extends undefined ? never :
    S extends { include: any } & (PostArgs | PostFindManyArgs)
    ? Post  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'User' ? UserGetPayload<S['include'][P]> :
        P extends 'PostLikes' ? Array < PostLikeGetPayload<S['include'][P]>>  :
        P extends 'PostComments' ? Array < PostCommentGetPayload<S['include'][P]>>  :
        P extends '_count' ? PostCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PostArgs | PostFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'User' ? UserGetPayload<S['select'][P]> :
        P extends 'PostLikes' ? Array < PostLikeGetPayload<S['select'][P]>>  :
        P extends 'PostComments' ? Array < PostCommentGetPayload<S['select'][P]>>  :
        P extends '_count' ? PostCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Post ? Post[P] : never
  } 
      : Post


  type PostCountArgs = Merge<
    Omit<PostFindManyArgs, 'select' | 'include'> & {
      select?: PostCountAggregateInputType | true
    }
  >

  export interface PostDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PostFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PostFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Post'> extends True ? Prisma__PostClient<PostGetPayload<T>> : Prisma__PostClient<PostGetPayload<T> | null, null>

    /**
     * Find one Post that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PostFindUniqueOrThrowArgs>
    ): Prisma__PostClient<PostGetPayload<T>>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PostFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PostFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Post'> extends True ? Prisma__PostClient<PostGetPayload<T>> : Prisma__PostClient<PostGetPayload<T> | null, null>

    /**
     * Find the first Post that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PostFindFirstOrThrowArgs>
    ): Prisma__PostClient<PostGetPayload<T>>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PostFindManyArgs>(
      args?: SelectSubset<T, PostFindManyArgs>
    ): PrismaPromise<Array<PostGetPayload<T>>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
    **/
    create<T extends PostCreateArgs>(
      args: SelectSubset<T, PostCreateArgs>
    ): Prisma__PostClient<PostGetPayload<T>>

    /**
     * Create many Posts.
     *     @param {PostCreateManyArgs} args - Arguments to create many Posts.
     *     @example
     *     // Create many Posts
     *     const post = await prisma.post.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PostCreateManyArgs>(
      args?: SelectSubset<T, PostCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
    **/
    delete<T extends PostDeleteArgs>(
      args: SelectSubset<T, PostDeleteArgs>
    ): Prisma__PostClient<PostGetPayload<T>>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PostUpdateArgs>(
      args: SelectSubset<T, PostUpdateArgs>
    ): Prisma__PostClient<PostGetPayload<T>>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PostDeleteManyArgs>(
      args?: SelectSubset<T, PostDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PostUpdateManyArgs>(
      args: SelectSubset<T, PostUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
    **/
    upsert<T extends PostUpsertArgs>(
      args: SelectSubset<T, PostUpsertArgs>
    ): Prisma__PostClient<PostGetPayload<T>>

    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PostClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    PostLikes<T extends PostLikeFindManyArgs= {}>(args?: Subset<T, PostLikeFindManyArgs>): PrismaPromise<Array<PostLikeGetPayload<T>>| Null>;

    PostComments<T extends PostCommentFindManyArgs= {}>(args?: Subset<T, PostCommentFindManyArgs>): PrismaPromise<Array<PostCommentGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Post base type for findUnique actions
   */
  export type PostFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Post
     * 
    **/
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostInclude | null
    /**
     * Filter, which Post to fetch.
     * 
    **/
    where: PostWhereUniqueInput
  }

  /**
   * Post: findUnique
   */
  export interface PostFindUniqueArgs extends PostFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Post
     * 
    **/
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostInclude | null
    /**
     * Filter, which Post to fetch.
     * 
    **/
    where: PostWhereUniqueInput
  }


  /**
   * Post base type for findFirst actions
   */
  export type PostFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Post
     * 
    **/
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostInclude | null
    /**
     * Filter, which Post to fetch.
     * 
    **/
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     * 
    **/
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     * 
    **/
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     * 
    **/
    distinct?: Enumerable<PostScalarFieldEnum>
  }

  /**
   * Post: findFirst
   */
  export interface PostFindFirstArgs extends PostFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Post
     * 
    **/
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostInclude | null
    /**
     * Filter, which Post to fetch.
     * 
    **/
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     * 
    **/
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     * 
    **/
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     * 
    **/
    distinct?: Enumerable<PostScalarFieldEnum>
  }


  /**
   * Post findMany
   */
  export type PostFindManyArgs = {
    /**
     * Select specific fields to fetch from the Post
     * 
    **/
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostInclude | null
    /**
     * Filter, which Posts to fetch.
     * 
    **/
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     * 
    **/
    orderBy?: Enumerable<PostOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     * 
    **/
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PostScalarFieldEnum>
  }


  /**
   * Post create
   */
  export type PostCreateArgs = {
    /**
     * Select specific fields to fetch from the Post
     * 
    **/
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostInclude | null
    /**
     * The data needed to create a Post.
     * 
    **/
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }


  /**
   * Post createMany
   */
  export type PostCreateManyArgs = {
    /**
     * The data used to create many Posts.
     * 
    **/
    data: Enumerable<PostCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Post update
   */
  export type PostUpdateArgs = {
    /**
     * Select specific fields to fetch from the Post
     * 
    **/
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostInclude | null
    /**
     * The data needed to update a Post.
     * 
    **/
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     * 
    **/
    where: PostWhereUniqueInput
  }


  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs = {
    /**
     * The data used to update Posts.
     * 
    **/
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     * 
    **/
    where?: PostWhereInput
  }


  /**
   * Post upsert
   */
  export type PostUpsertArgs = {
    /**
     * Select specific fields to fetch from the Post
     * 
    **/
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostInclude | null
    /**
     * The filter to search for the Post to update in case it exists.
     * 
    **/
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     * 
    **/
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }


  /**
   * Post delete
   */
  export type PostDeleteArgs = {
    /**
     * Select specific fields to fetch from the Post
     * 
    **/
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostInclude | null
    /**
     * Filter which Post to delete.
     * 
    **/
    where: PostWhereUniqueInput
  }


  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs = {
    /**
     * Filter which Posts to delete
     * 
    **/
    where?: PostWhereInput
  }


  /**
   * Post without action
   */
  export type PostArgs = {
    /**
     * Select specific fields to fetch from the Post
     * 
    **/
    select?: PostSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostInclude | null
  }



  /**
   * Model PostLike
   */


  export type AggregatePostLike = {
    _count: PostLikeCountAggregateOutputType | null
    _avg: PostLikeAvgAggregateOutputType | null
    _sum: PostLikeSumAggregateOutputType | null
    _min: PostLikeMinAggregateOutputType | null
    _max: PostLikeMaxAggregateOutputType | null
  }

  export type PostLikeAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    postId: number | null
  }

  export type PostLikeSumAggregateOutputType = {
    id: number | null
    userId: number | null
    postId: number | null
  }

  export type PostLikeMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: number | null
    postId: number | null
  }

  export type PostLikeMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: number | null
    postId: number | null
  }

  export type PostLikeCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    userId: number
    postId: number
    _all: number
  }


  export type PostLikeAvgAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
  }

  export type PostLikeSumAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
  }

  export type PostLikeMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    postId?: true
  }

  export type PostLikeMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    postId?: true
  }

  export type PostLikeCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    postId?: true
    _all?: true
  }

  export type PostLikeAggregateArgs = {
    /**
     * Filter which PostLike to aggregate.
     * 
    **/
    where?: PostLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostLikes to fetch.
     * 
    **/
    orderBy?: Enumerable<PostLikeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PostLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostLikes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostLikes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostLikes
    **/
    _count?: true | PostLikeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostLikeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostLikeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostLikeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostLikeMaxAggregateInputType
  }

  export type GetPostLikeAggregateType<T extends PostLikeAggregateArgs> = {
        [P in keyof T & keyof AggregatePostLike]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostLike[P]>
      : GetScalarType<T[P], AggregatePostLike[P]>
  }




  export type PostLikeGroupByArgs = {
    where?: PostLikeWhereInput
    orderBy?: Enumerable<PostLikeOrderByWithAggregationInput>
    by: Array<PostLikeScalarFieldEnum>
    having?: PostLikeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostLikeCountAggregateInputType | true
    _avg?: PostLikeAvgAggregateInputType
    _sum?: PostLikeSumAggregateInputType
    _min?: PostLikeMinAggregateInputType
    _max?: PostLikeMaxAggregateInputType
  }


  export type PostLikeGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    userId: number
    postId: number
    _count: PostLikeCountAggregateOutputType | null
    _avg: PostLikeAvgAggregateOutputType | null
    _sum: PostLikeSumAggregateOutputType | null
    _min: PostLikeMinAggregateOutputType | null
    _max: PostLikeMaxAggregateOutputType | null
  }

  type GetPostLikeGroupByPayload<T extends PostLikeGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PostLikeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostLikeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostLikeGroupByOutputType[P]>
            : GetScalarType<T[P], PostLikeGroupByOutputType[P]>
        }
      >
    >


  export type PostLikeSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserArgs
    Post?: boolean | PostArgs
    userId?: boolean
    postId?: boolean
  }


  export type PostLikeInclude = {
    User?: boolean | UserArgs
    Post?: boolean | PostArgs
  } 

  export type PostLikeGetPayload<S extends boolean | null | undefined | PostLikeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PostLike :
    S extends undefined ? never :
    S extends { include: any } & (PostLikeArgs | PostLikeFindManyArgs)
    ? PostLike  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'User' ? UserGetPayload<S['include'][P]> :
        P extends 'Post' ? PostGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PostLikeArgs | PostLikeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'User' ? UserGetPayload<S['select'][P]> :
        P extends 'Post' ? PostGetPayload<S['select'][P]> :  P extends keyof PostLike ? PostLike[P] : never
  } 
      : PostLike


  type PostLikeCountArgs = Merge<
    Omit<PostLikeFindManyArgs, 'select' | 'include'> & {
      select?: PostLikeCountAggregateInputType | true
    }
  >

  export interface PostLikeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one PostLike that matches the filter.
     * @param {PostLikeFindUniqueArgs} args - Arguments to find a PostLike
     * @example
     * // Get one PostLike
     * const postLike = await prisma.postLike.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PostLikeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PostLikeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PostLike'> extends True ? Prisma__PostLikeClient<PostLikeGetPayload<T>> : Prisma__PostLikeClient<PostLikeGetPayload<T> | null, null>

    /**
     * Find one PostLike that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PostLikeFindUniqueOrThrowArgs} args - Arguments to find a PostLike
     * @example
     * // Get one PostLike
     * const postLike = await prisma.postLike.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PostLikeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PostLikeFindUniqueOrThrowArgs>
    ): Prisma__PostLikeClient<PostLikeGetPayload<T>>

    /**
     * Find the first PostLike that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikeFindFirstArgs} args - Arguments to find a PostLike
     * @example
     * // Get one PostLike
     * const postLike = await prisma.postLike.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PostLikeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PostLikeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PostLike'> extends True ? Prisma__PostLikeClient<PostLikeGetPayload<T>> : Prisma__PostLikeClient<PostLikeGetPayload<T> | null, null>

    /**
     * Find the first PostLike that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikeFindFirstOrThrowArgs} args - Arguments to find a PostLike
     * @example
     * // Get one PostLike
     * const postLike = await prisma.postLike.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PostLikeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PostLikeFindFirstOrThrowArgs>
    ): Prisma__PostLikeClient<PostLikeGetPayload<T>>

    /**
     * Find zero or more PostLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostLikes
     * const postLikes = await prisma.postLike.findMany()
     * 
     * // Get first 10 PostLikes
     * const postLikes = await prisma.postLike.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postLikeWithIdOnly = await prisma.postLike.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PostLikeFindManyArgs>(
      args?: SelectSubset<T, PostLikeFindManyArgs>
    ): PrismaPromise<Array<PostLikeGetPayload<T>>>

    /**
     * Create a PostLike.
     * @param {PostLikeCreateArgs} args - Arguments to create a PostLike.
     * @example
     * // Create one PostLike
     * const PostLike = await prisma.postLike.create({
     *   data: {
     *     // ... data to create a PostLike
     *   }
     * })
     * 
    **/
    create<T extends PostLikeCreateArgs>(
      args: SelectSubset<T, PostLikeCreateArgs>
    ): Prisma__PostLikeClient<PostLikeGetPayload<T>>

    /**
     * Create many PostLikes.
     *     @param {PostLikeCreateManyArgs} args - Arguments to create many PostLikes.
     *     @example
     *     // Create many PostLikes
     *     const postLike = await prisma.postLike.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PostLikeCreateManyArgs>(
      args?: SelectSubset<T, PostLikeCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PostLike.
     * @param {PostLikeDeleteArgs} args - Arguments to delete one PostLike.
     * @example
     * // Delete one PostLike
     * const PostLike = await prisma.postLike.delete({
     *   where: {
     *     // ... filter to delete one PostLike
     *   }
     * })
     * 
    **/
    delete<T extends PostLikeDeleteArgs>(
      args: SelectSubset<T, PostLikeDeleteArgs>
    ): Prisma__PostLikeClient<PostLikeGetPayload<T>>

    /**
     * Update one PostLike.
     * @param {PostLikeUpdateArgs} args - Arguments to update one PostLike.
     * @example
     * // Update one PostLike
     * const postLike = await prisma.postLike.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PostLikeUpdateArgs>(
      args: SelectSubset<T, PostLikeUpdateArgs>
    ): Prisma__PostLikeClient<PostLikeGetPayload<T>>

    /**
     * Delete zero or more PostLikes.
     * @param {PostLikeDeleteManyArgs} args - Arguments to filter PostLikes to delete.
     * @example
     * // Delete a few PostLikes
     * const { count } = await prisma.postLike.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PostLikeDeleteManyArgs>(
      args?: SelectSubset<T, PostLikeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostLikes
     * const postLike = await prisma.postLike.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PostLikeUpdateManyArgs>(
      args: SelectSubset<T, PostLikeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PostLike.
     * @param {PostLikeUpsertArgs} args - Arguments to update or create a PostLike.
     * @example
     * // Update or create a PostLike
     * const postLike = await prisma.postLike.upsert({
     *   create: {
     *     // ... data to create a PostLike
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostLike we want to update
     *   }
     * })
    **/
    upsert<T extends PostLikeUpsertArgs>(
      args: SelectSubset<T, PostLikeUpsertArgs>
    ): Prisma__PostLikeClient<PostLikeGetPayload<T>>

    /**
     * Count the number of PostLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikeCountArgs} args - Arguments to filter PostLikes to count.
     * @example
     * // Count the number of PostLikes
     * const count = await prisma.postLike.count({
     *   where: {
     *     // ... the filter for the PostLikes we want to count
     *   }
     * })
    **/
    count<T extends PostLikeCountArgs>(
      args?: Subset<T, PostLikeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostLikeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostLikeAggregateArgs>(args: Subset<T, PostLikeAggregateArgs>): PrismaPromise<GetPostLikeAggregateType<T>>

    /**
     * Group by PostLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostLikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostLikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostLikeGroupByArgs['orderBy'] }
        : { orderBy?: PostLikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostLikeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostLikeGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PostLike.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PostLikeClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    Post<T extends PostArgs= {}>(args?: Subset<T, PostArgs>): Prisma__PostClient<PostGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PostLike base type for findUnique actions
   */
  export type PostLikeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PostLike
     * 
    **/
    select?: PostLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostLikeInclude | null
    /**
     * Filter, which PostLike to fetch.
     * 
    **/
    where: PostLikeWhereUniqueInput
  }

  /**
   * PostLike: findUnique
   */
  export interface PostLikeFindUniqueArgs extends PostLikeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PostLike findUniqueOrThrow
   */
  export type PostLikeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PostLike
     * 
    **/
    select?: PostLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostLikeInclude | null
    /**
     * Filter, which PostLike to fetch.
     * 
    **/
    where: PostLikeWhereUniqueInput
  }


  /**
   * PostLike base type for findFirst actions
   */
  export type PostLikeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PostLike
     * 
    **/
    select?: PostLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostLikeInclude | null
    /**
     * Filter, which PostLike to fetch.
     * 
    **/
    where?: PostLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostLikes to fetch.
     * 
    **/
    orderBy?: Enumerable<PostLikeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostLikes.
     * 
    **/
    cursor?: PostLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostLikes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostLikes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostLikes.
     * 
    **/
    distinct?: Enumerable<PostLikeScalarFieldEnum>
  }

  /**
   * PostLike: findFirst
   */
  export interface PostLikeFindFirstArgs extends PostLikeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PostLike findFirstOrThrow
   */
  export type PostLikeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PostLike
     * 
    **/
    select?: PostLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostLikeInclude | null
    /**
     * Filter, which PostLike to fetch.
     * 
    **/
    where?: PostLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostLikes to fetch.
     * 
    **/
    orderBy?: Enumerable<PostLikeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostLikes.
     * 
    **/
    cursor?: PostLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostLikes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostLikes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostLikes.
     * 
    **/
    distinct?: Enumerable<PostLikeScalarFieldEnum>
  }


  /**
   * PostLike findMany
   */
  export type PostLikeFindManyArgs = {
    /**
     * Select specific fields to fetch from the PostLike
     * 
    **/
    select?: PostLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostLikeInclude | null
    /**
     * Filter, which PostLikes to fetch.
     * 
    **/
    where?: PostLikeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostLikes to fetch.
     * 
    **/
    orderBy?: Enumerable<PostLikeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostLikes.
     * 
    **/
    cursor?: PostLikeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostLikes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostLikes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PostLikeScalarFieldEnum>
  }


  /**
   * PostLike create
   */
  export type PostLikeCreateArgs = {
    /**
     * Select specific fields to fetch from the PostLike
     * 
    **/
    select?: PostLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostLikeInclude | null
    /**
     * The data needed to create a PostLike.
     * 
    **/
    data: XOR<PostLikeCreateInput, PostLikeUncheckedCreateInput>
  }


  /**
   * PostLike createMany
   */
  export type PostLikeCreateManyArgs = {
    /**
     * The data used to create many PostLikes.
     * 
    **/
    data: Enumerable<PostLikeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PostLike update
   */
  export type PostLikeUpdateArgs = {
    /**
     * Select specific fields to fetch from the PostLike
     * 
    **/
    select?: PostLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostLikeInclude | null
    /**
     * The data needed to update a PostLike.
     * 
    **/
    data: XOR<PostLikeUpdateInput, PostLikeUncheckedUpdateInput>
    /**
     * Choose, which PostLike to update.
     * 
    **/
    where: PostLikeWhereUniqueInput
  }


  /**
   * PostLike updateMany
   */
  export type PostLikeUpdateManyArgs = {
    /**
     * The data used to update PostLikes.
     * 
    **/
    data: XOR<PostLikeUpdateManyMutationInput, PostLikeUncheckedUpdateManyInput>
    /**
     * Filter which PostLikes to update
     * 
    **/
    where?: PostLikeWhereInput
  }


  /**
   * PostLike upsert
   */
  export type PostLikeUpsertArgs = {
    /**
     * Select specific fields to fetch from the PostLike
     * 
    **/
    select?: PostLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostLikeInclude | null
    /**
     * The filter to search for the PostLike to update in case it exists.
     * 
    **/
    where: PostLikeWhereUniqueInput
    /**
     * In case the PostLike found by the `where` argument doesn't exist, create a new PostLike with this data.
     * 
    **/
    create: XOR<PostLikeCreateInput, PostLikeUncheckedCreateInput>
    /**
     * In case the PostLike was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PostLikeUpdateInput, PostLikeUncheckedUpdateInput>
  }


  /**
   * PostLike delete
   */
  export type PostLikeDeleteArgs = {
    /**
     * Select specific fields to fetch from the PostLike
     * 
    **/
    select?: PostLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostLikeInclude | null
    /**
     * Filter which PostLike to delete.
     * 
    **/
    where: PostLikeWhereUniqueInput
  }


  /**
   * PostLike deleteMany
   */
  export type PostLikeDeleteManyArgs = {
    /**
     * Filter which PostLikes to delete
     * 
    **/
    where?: PostLikeWhereInput
  }


  /**
   * PostLike without action
   */
  export type PostLikeArgs = {
    /**
     * Select specific fields to fetch from the PostLike
     * 
    **/
    select?: PostLikeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostLikeInclude | null
  }



  /**
   * Model PostComment
   */


  export type AggregatePostComment = {
    _count: PostCommentCountAggregateOutputType | null
    _avg: PostCommentAvgAggregateOutputType | null
    _sum: PostCommentSumAggregateOutputType | null
    _min: PostCommentMinAggregateOutputType | null
    _max: PostCommentMaxAggregateOutputType | null
  }

  export type PostCommentAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    postId: number | null
  }

  export type PostCommentSumAggregateOutputType = {
    id: number | null
    userId: number | null
    postId: number | null
  }

  export type PostCommentMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: number | null
    postId: number | null
    text: string | null
  }

  export type PostCommentMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: number | null
    postId: number | null
    text: string | null
  }

  export type PostCommentCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    userId: number
    postId: number
    text: number
    _all: number
  }


  export type PostCommentAvgAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
  }

  export type PostCommentSumAggregateInputType = {
    id?: true
    userId?: true
    postId?: true
  }

  export type PostCommentMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    postId?: true
    text?: true
  }

  export type PostCommentMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    postId?: true
    text?: true
  }

  export type PostCommentCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    postId?: true
    text?: true
    _all?: true
  }

  export type PostCommentAggregateArgs = {
    /**
     * Filter which PostComment to aggregate.
     * 
    **/
    where?: PostCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostComments to fetch.
     * 
    **/
    orderBy?: Enumerable<PostCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PostCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostComments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostComments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostComments
    **/
    _count?: true | PostCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostCommentMaxAggregateInputType
  }

  export type GetPostCommentAggregateType<T extends PostCommentAggregateArgs> = {
        [P in keyof T & keyof AggregatePostComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostComment[P]>
      : GetScalarType<T[P], AggregatePostComment[P]>
  }




  export type PostCommentGroupByArgs = {
    where?: PostCommentWhereInput
    orderBy?: Enumerable<PostCommentOrderByWithAggregationInput>
    by: Array<PostCommentScalarFieldEnum>
    having?: PostCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCommentCountAggregateInputType | true
    _avg?: PostCommentAvgAggregateInputType
    _sum?: PostCommentSumAggregateInputType
    _min?: PostCommentMinAggregateInputType
    _max?: PostCommentMaxAggregateInputType
  }


  export type PostCommentGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    userId: number
    postId: number
    text: string
    _count: PostCommentCountAggregateOutputType | null
    _avg: PostCommentAvgAggregateOutputType | null
    _sum: PostCommentSumAggregateOutputType | null
    _min: PostCommentMinAggregateOutputType | null
    _max: PostCommentMaxAggregateOutputType | null
  }

  type GetPostCommentGroupByPayload<T extends PostCommentGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PostCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostCommentGroupByOutputType[P]>
            : GetScalarType<T[P], PostCommentGroupByOutputType[P]>
        }
      >
    >


  export type PostCommentSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | UserArgs
    Post?: boolean | PostArgs
    userId?: boolean
    postId?: boolean
    text?: boolean
  }


  export type PostCommentInclude = {
    User?: boolean | UserArgs
    Post?: boolean | PostArgs
  } 

  export type PostCommentGetPayload<S extends boolean | null | undefined | PostCommentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PostComment :
    S extends undefined ? never :
    S extends { include: any } & (PostCommentArgs | PostCommentFindManyArgs)
    ? PostComment  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'User' ? UserGetPayload<S['include'][P]> :
        P extends 'Post' ? PostGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (PostCommentArgs | PostCommentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'User' ? UserGetPayload<S['select'][P]> :
        P extends 'Post' ? PostGetPayload<S['select'][P]> :  P extends keyof PostComment ? PostComment[P] : never
  } 
      : PostComment


  type PostCommentCountArgs = Merge<
    Omit<PostCommentFindManyArgs, 'select' | 'include'> & {
      select?: PostCommentCountAggregateInputType | true
    }
  >

  export interface PostCommentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one PostComment that matches the filter.
     * @param {PostCommentFindUniqueArgs} args - Arguments to find a PostComment
     * @example
     * // Get one PostComment
     * const postComment = await prisma.postComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PostCommentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PostCommentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PostComment'> extends True ? Prisma__PostCommentClient<PostCommentGetPayload<T>> : Prisma__PostCommentClient<PostCommentGetPayload<T> | null, null>

    /**
     * Find one PostComment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PostCommentFindUniqueOrThrowArgs} args - Arguments to find a PostComment
     * @example
     * // Get one PostComment
     * const postComment = await prisma.postComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PostCommentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PostCommentFindUniqueOrThrowArgs>
    ): Prisma__PostCommentClient<PostCommentGetPayload<T>>

    /**
     * Find the first PostComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCommentFindFirstArgs} args - Arguments to find a PostComment
     * @example
     * // Get one PostComment
     * const postComment = await prisma.postComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PostCommentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PostCommentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PostComment'> extends True ? Prisma__PostCommentClient<PostCommentGetPayload<T>> : Prisma__PostCommentClient<PostCommentGetPayload<T> | null, null>

    /**
     * Find the first PostComment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCommentFindFirstOrThrowArgs} args - Arguments to find a PostComment
     * @example
     * // Get one PostComment
     * const postComment = await prisma.postComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PostCommentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PostCommentFindFirstOrThrowArgs>
    ): Prisma__PostCommentClient<PostCommentGetPayload<T>>

    /**
     * Find zero or more PostComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostComments
     * const postComments = await prisma.postComment.findMany()
     * 
     * // Get first 10 PostComments
     * const postComments = await prisma.postComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postCommentWithIdOnly = await prisma.postComment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PostCommentFindManyArgs>(
      args?: SelectSubset<T, PostCommentFindManyArgs>
    ): PrismaPromise<Array<PostCommentGetPayload<T>>>

    /**
     * Create a PostComment.
     * @param {PostCommentCreateArgs} args - Arguments to create a PostComment.
     * @example
     * // Create one PostComment
     * const PostComment = await prisma.postComment.create({
     *   data: {
     *     // ... data to create a PostComment
     *   }
     * })
     * 
    **/
    create<T extends PostCommentCreateArgs>(
      args: SelectSubset<T, PostCommentCreateArgs>
    ): Prisma__PostCommentClient<PostCommentGetPayload<T>>

    /**
     * Create many PostComments.
     *     @param {PostCommentCreateManyArgs} args - Arguments to create many PostComments.
     *     @example
     *     // Create many PostComments
     *     const postComment = await prisma.postComment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PostCommentCreateManyArgs>(
      args?: SelectSubset<T, PostCommentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PostComment.
     * @param {PostCommentDeleteArgs} args - Arguments to delete one PostComment.
     * @example
     * // Delete one PostComment
     * const PostComment = await prisma.postComment.delete({
     *   where: {
     *     // ... filter to delete one PostComment
     *   }
     * })
     * 
    **/
    delete<T extends PostCommentDeleteArgs>(
      args: SelectSubset<T, PostCommentDeleteArgs>
    ): Prisma__PostCommentClient<PostCommentGetPayload<T>>

    /**
     * Update one PostComment.
     * @param {PostCommentUpdateArgs} args - Arguments to update one PostComment.
     * @example
     * // Update one PostComment
     * const postComment = await prisma.postComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PostCommentUpdateArgs>(
      args: SelectSubset<T, PostCommentUpdateArgs>
    ): Prisma__PostCommentClient<PostCommentGetPayload<T>>

    /**
     * Delete zero or more PostComments.
     * @param {PostCommentDeleteManyArgs} args - Arguments to filter PostComments to delete.
     * @example
     * // Delete a few PostComments
     * const { count } = await prisma.postComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PostCommentDeleteManyArgs>(
      args?: SelectSubset<T, PostCommentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostComments
     * const postComment = await prisma.postComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PostCommentUpdateManyArgs>(
      args: SelectSubset<T, PostCommentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PostComment.
     * @param {PostCommentUpsertArgs} args - Arguments to update or create a PostComment.
     * @example
     * // Update or create a PostComment
     * const postComment = await prisma.postComment.upsert({
     *   create: {
     *     // ... data to create a PostComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostComment we want to update
     *   }
     * })
    **/
    upsert<T extends PostCommentUpsertArgs>(
      args: SelectSubset<T, PostCommentUpsertArgs>
    ): Prisma__PostCommentClient<PostCommentGetPayload<T>>

    /**
     * Count the number of PostComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCommentCountArgs} args - Arguments to filter PostComments to count.
     * @example
     * // Count the number of PostComments
     * const count = await prisma.postComment.count({
     *   where: {
     *     // ... the filter for the PostComments we want to count
     *   }
     * })
    **/
    count<T extends PostCommentCountArgs>(
      args?: Subset<T, PostCommentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostCommentAggregateArgs>(args: Subset<T, PostCommentAggregateArgs>): PrismaPromise<GetPostCommentAggregateType<T>>

    /**
     * Group by PostComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostCommentGroupByArgs['orderBy'] }
        : { orderBy?: PostCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostCommentGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PostComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PostCommentClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    User<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    Post<T extends PostArgs= {}>(args?: Subset<T, PostArgs>): Prisma__PostClient<PostGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PostComment base type for findUnique actions
   */
  export type PostCommentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PostComment
     * 
    **/
    select?: PostCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostCommentInclude | null
    /**
     * Filter, which PostComment to fetch.
     * 
    **/
    where: PostCommentWhereUniqueInput
  }

  /**
   * PostComment: findUnique
   */
  export interface PostCommentFindUniqueArgs extends PostCommentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PostComment findUniqueOrThrow
   */
  export type PostCommentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PostComment
     * 
    **/
    select?: PostCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostCommentInclude | null
    /**
     * Filter, which PostComment to fetch.
     * 
    **/
    where: PostCommentWhereUniqueInput
  }


  /**
   * PostComment base type for findFirst actions
   */
  export type PostCommentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PostComment
     * 
    **/
    select?: PostCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostCommentInclude | null
    /**
     * Filter, which PostComment to fetch.
     * 
    **/
    where?: PostCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostComments to fetch.
     * 
    **/
    orderBy?: Enumerable<PostCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostComments.
     * 
    **/
    cursor?: PostCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostComments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostComments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostComments.
     * 
    **/
    distinct?: Enumerable<PostCommentScalarFieldEnum>
  }

  /**
   * PostComment: findFirst
   */
  export interface PostCommentFindFirstArgs extends PostCommentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PostComment findFirstOrThrow
   */
  export type PostCommentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PostComment
     * 
    **/
    select?: PostCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostCommentInclude | null
    /**
     * Filter, which PostComment to fetch.
     * 
    **/
    where?: PostCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostComments to fetch.
     * 
    **/
    orderBy?: Enumerable<PostCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostComments.
     * 
    **/
    cursor?: PostCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostComments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostComments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostComments.
     * 
    **/
    distinct?: Enumerable<PostCommentScalarFieldEnum>
  }


  /**
   * PostComment findMany
   */
  export type PostCommentFindManyArgs = {
    /**
     * Select specific fields to fetch from the PostComment
     * 
    **/
    select?: PostCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostCommentInclude | null
    /**
     * Filter, which PostComments to fetch.
     * 
    **/
    where?: PostCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostComments to fetch.
     * 
    **/
    orderBy?: Enumerable<PostCommentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostComments.
     * 
    **/
    cursor?: PostCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostComments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostComments.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PostCommentScalarFieldEnum>
  }


  /**
   * PostComment create
   */
  export type PostCommentCreateArgs = {
    /**
     * Select specific fields to fetch from the PostComment
     * 
    **/
    select?: PostCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostCommentInclude | null
    /**
     * The data needed to create a PostComment.
     * 
    **/
    data: XOR<PostCommentCreateInput, PostCommentUncheckedCreateInput>
  }


  /**
   * PostComment createMany
   */
  export type PostCommentCreateManyArgs = {
    /**
     * The data used to create many PostComments.
     * 
    **/
    data: Enumerable<PostCommentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PostComment update
   */
  export type PostCommentUpdateArgs = {
    /**
     * Select specific fields to fetch from the PostComment
     * 
    **/
    select?: PostCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostCommentInclude | null
    /**
     * The data needed to update a PostComment.
     * 
    **/
    data: XOR<PostCommentUpdateInput, PostCommentUncheckedUpdateInput>
    /**
     * Choose, which PostComment to update.
     * 
    **/
    where: PostCommentWhereUniqueInput
  }


  /**
   * PostComment updateMany
   */
  export type PostCommentUpdateManyArgs = {
    /**
     * The data used to update PostComments.
     * 
    **/
    data: XOR<PostCommentUpdateManyMutationInput, PostCommentUncheckedUpdateManyInput>
    /**
     * Filter which PostComments to update
     * 
    **/
    where?: PostCommentWhereInput
  }


  /**
   * PostComment upsert
   */
  export type PostCommentUpsertArgs = {
    /**
     * Select specific fields to fetch from the PostComment
     * 
    **/
    select?: PostCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostCommentInclude | null
    /**
     * The filter to search for the PostComment to update in case it exists.
     * 
    **/
    where: PostCommentWhereUniqueInput
    /**
     * In case the PostComment found by the `where` argument doesn't exist, create a new PostComment with this data.
     * 
    **/
    create: XOR<PostCommentCreateInput, PostCommentUncheckedCreateInput>
    /**
     * In case the PostComment was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PostCommentUpdateInput, PostCommentUncheckedUpdateInput>
  }


  /**
   * PostComment delete
   */
  export type PostCommentDeleteArgs = {
    /**
     * Select specific fields to fetch from the PostComment
     * 
    **/
    select?: PostCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostCommentInclude | null
    /**
     * Filter which PostComment to delete.
     * 
    **/
    where: PostCommentWhereUniqueInput
  }


  /**
   * PostComment deleteMany
   */
  export type PostCommentDeleteManyArgs = {
    /**
     * Filter which PostComments to delete
     * 
    **/
    where?: PostCommentWhereInput
  }


  /**
   * PostComment without action
   */
  export type PostCommentArgs = {
    /**
     * Select specific fields to fetch from the PostComment
     * 
    **/
    select?: PostCommentSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PostCommentInclude | null
  }



  /**
   * Model PostAttachment
   */


  export type AggregatePostAttachment = {
    _count: PostAttachmentCountAggregateOutputType | null
    _avg: PostAttachmentAvgAggregateOutputType | null
    _sum: PostAttachmentSumAggregateOutputType | null
    _min: PostAttachmentMinAggregateOutputType | null
    _max: PostAttachmentMaxAggregateOutputType | null
  }

  export type PostAttachmentAvgAggregateOutputType = {
    id: number | null
  }

  export type PostAttachmentSumAggregateOutputType = {
    id: number | null
  }

  export type PostAttachmentMinAggregateOutputType = {
    id: number | null
    type: DocumentType | null
    s3Key: string | null
  }

  export type PostAttachmentMaxAggregateOutputType = {
    id: number | null
    type: DocumentType | null
    s3Key: string | null
  }

  export type PostAttachmentCountAggregateOutputType = {
    id: number
    type: number
    s3Key: number
    _all: number
  }


  export type PostAttachmentAvgAggregateInputType = {
    id?: true
  }

  export type PostAttachmentSumAggregateInputType = {
    id?: true
  }

  export type PostAttachmentMinAggregateInputType = {
    id?: true
    type?: true
    s3Key?: true
  }

  export type PostAttachmentMaxAggregateInputType = {
    id?: true
    type?: true
    s3Key?: true
  }

  export type PostAttachmentCountAggregateInputType = {
    id?: true
    type?: true
    s3Key?: true
    _all?: true
  }

  export type PostAttachmentAggregateArgs = {
    /**
     * Filter which PostAttachment to aggregate.
     * 
    **/
    where?: PostAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostAttachments to fetch.
     * 
    **/
    orderBy?: Enumerable<PostAttachmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PostAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostAttachments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostAttachments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostAttachments
    **/
    _count?: true | PostAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostAttachmentMaxAggregateInputType
  }

  export type GetPostAttachmentAggregateType<T extends PostAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregatePostAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostAttachment[P]>
      : GetScalarType<T[P], AggregatePostAttachment[P]>
  }




  export type PostAttachmentGroupByArgs = {
    where?: PostAttachmentWhereInput
    orderBy?: Enumerable<PostAttachmentOrderByWithAggregationInput>
    by: Array<PostAttachmentScalarFieldEnum>
    having?: PostAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostAttachmentCountAggregateInputType | true
    _avg?: PostAttachmentAvgAggregateInputType
    _sum?: PostAttachmentSumAggregateInputType
    _min?: PostAttachmentMinAggregateInputType
    _max?: PostAttachmentMaxAggregateInputType
  }


  export type PostAttachmentGroupByOutputType = {
    id: number
    type: DocumentType
    s3Key: string
    _count: PostAttachmentCountAggregateOutputType | null
    _avg: PostAttachmentAvgAggregateOutputType | null
    _sum: PostAttachmentSumAggregateOutputType | null
    _min: PostAttachmentMinAggregateOutputType | null
    _max: PostAttachmentMaxAggregateOutputType | null
  }

  type GetPostAttachmentGroupByPayload<T extends PostAttachmentGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PostAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], PostAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type PostAttachmentSelect = {
    id?: boolean
    type?: boolean
    s3Key?: boolean
  }


  export type PostAttachmentGetPayload<S extends boolean | null | undefined | PostAttachmentArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? PostAttachment :
    S extends undefined ? never :
    S extends { include: any } & (PostAttachmentArgs | PostAttachmentFindManyArgs)
    ? PostAttachment 
    : S extends { select: any } & (PostAttachmentArgs | PostAttachmentFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof PostAttachment ? PostAttachment[P] : never
  } 
      : PostAttachment


  type PostAttachmentCountArgs = Merge<
    Omit<PostAttachmentFindManyArgs, 'select' | 'include'> & {
      select?: PostAttachmentCountAggregateInputType | true
    }
  >

  export interface PostAttachmentDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one PostAttachment that matches the filter.
     * @param {PostAttachmentFindUniqueArgs} args - Arguments to find a PostAttachment
     * @example
     * // Get one PostAttachment
     * const postAttachment = await prisma.postAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PostAttachmentFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PostAttachmentFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PostAttachment'> extends True ? Prisma__PostAttachmentClient<PostAttachmentGetPayload<T>> : Prisma__PostAttachmentClient<PostAttachmentGetPayload<T> | null, null>

    /**
     * Find one PostAttachment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PostAttachmentFindUniqueOrThrowArgs} args - Arguments to find a PostAttachment
     * @example
     * // Get one PostAttachment
     * const postAttachment = await prisma.postAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PostAttachmentFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, PostAttachmentFindUniqueOrThrowArgs>
    ): Prisma__PostAttachmentClient<PostAttachmentGetPayload<T>>

    /**
     * Find the first PostAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAttachmentFindFirstArgs} args - Arguments to find a PostAttachment
     * @example
     * // Get one PostAttachment
     * const postAttachment = await prisma.postAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PostAttachmentFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PostAttachmentFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PostAttachment'> extends True ? Prisma__PostAttachmentClient<PostAttachmentGetPayload<T>> : Prisma__PostAttachmentClient<PostAttachmentGetPayload<T> | null, null>

    /**
     * Find the first PostAttachment that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAttachmentFindFirstOrThrowArgs} args - Arguments to find a PostAttachment
     * @example
     * // Get one PostAttachment
     * const postAttachment = await prisma.postAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PostAttachmentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PostAttachmentFindFirstOrThrowArgs>
    ): Prisma__PostAttachmentClient<PostAttachmentGetPayload<T>>

    /**
     * Find zero or more PostAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAttachmentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostAttachments
     * const postAttachments = await prisma.postAttachment.findMany()
     * 
     * // Get first 10 PostAttachments
     * const postAttachments = await prisma.postAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postAttachmentWithIdOnly = await prisma.postAttachment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PostAttachmentFindManyArgs>(
      args?: SelectSubset<T, PostAttachmentFindManyArgs>
    ): PrismaPromise<Array<PostAttachmentGetPayload<T>>>

    /**
     * Create a PostAttachment.
     * @param {PostAttachmentCreateArgs} args - Arguments to create a PostAttachment.
     * @example
     * // Create one PostAttachment
     * const PostAttachment = await prisma.postAttachment.create({
     *   data: {
     *     // ... data to create a PostAttachment
     *   }
     * })
     * 
    **/
    create<T extends PostAttachmentCreateArgs>(
      args: SelectSubset<T, PostAttachmentCreateArgs>
    ): Prisma__PostAttachmentClient<PostAttachmentGetPayload<T>>

    /**
     * Create many PostAttachments.
     *     @param {PostAttachmentCreateManyArgs} args - Arguments to create many PostAttachments.
     *     @example
     *     // Create many PostAttachments
     *     const postAttachment = await prisma.postAttachment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PostAttachmentCreateManyArgs>(
      args?: SelectSubset<T, PostAttachmentCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PostAttachment.
     * @param {PostAttachmentDeleteArgs} args - Arguments to delete one PostAttachment.
     * @example
     * // Delete one PostAttachment
     * const PostAttachment = await prisma.postAttachment.delete({
     *   where: {
     *     // ... filter to delete one PostAttachment
     *   }
     * })
     * 
    **/
    delete<T extends PostAttachmentDeleteArgs>(
      args: SelectSubset<T, PostAttachmentDeleteArgs>
    ): Prisma__PostAttachmentClient<PostAttachmentGetPayload<T>>

    /**
     * Update one PostAttachment.
     * @param {PostAttachmentUpdateArgs} args - Arguments to update one PostAttachment.
     * @example
     * // Update one PostAttachment
     * const postAttachment = await prisma.postAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PostAttachmentUpdateArgs>(
      args: SelectSubset<T, PostAttachmentUpdateArgs>
    ): Prisma__PostAttachmentClient<PostAttachmentGetPayload<T>>

    /**
     * Delete zero or more PostAttachments.
     * @param {PostAttachmentDeleteManyArgs} args - Arguments to filter PostAttachments to delete.
     * @example
     * // Delete a few PostAttachments
     * const { count } = await prisma.postAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PostAttachmentDeleteManyArgs>(
      args?: SelectSubset<T, PostAttachmentDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostAttachments
     * const postAttachment = await prisma.postAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PostAttachmentUpdateManyArgs>(
      args: SelectSubset<T, PostAttachmentUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PostAttachment.
     * @param {PostAttachmentUpsertArgs} args - Arguments to update or create a PostAttachment.
     * @example
     * // Update or create a PostAttachment
     * const postAttachment = await prisma.postAttachment.upsert({
     *   create: {
     *     // ... data to create a PostAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostAttachment we want to update
     *   }
     * })
    **/
    upsert<T extends PostAttachmentUpsertArgs>(
      args: SelectSubset<T, PostAttachmentUpsertArgs>
    ): Prisma__PostAttachmentClient<PostAttachmentGetPayload<T>>

    /**
     * Count the number of PostAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAttachmentCountArgs} args - Arguments to filter PostAttachments to count.
     * @example
     * // Count the number of PostAttachments
     * const count = await prisma.postAttachment.count({
     *   where: {
     *     // ... the filter for the PostAttachments we want to count
     *   }
     * })
    **/
    count<T extends PostAttachmentCountArgs>(
      args?: Subset<T, PostAttachmentCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAttachmentAggregateArgs>(args: Subset<T, PostAttachmentAggregateArgs>): PrismaPromise<GetPostAttachmentAggregateType<T>>

    /**
     * Group by PostAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: PostAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostAttachmentGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for PostAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PostAttachmentClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * PostAttachment base type for findUnique actions
   */
  export type PostAttachmentFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the PostAttachment
     * 
    **/
    select?: PostAttachmentSelect | null
    /**
     * Filter, which PostAttachment to fetch.
     * 
    **/
    where: PostAttachmentWhereUniqueInput
  }

  /**
   * PostAttachment: findUnique
   */
  export interface PostAttachmentFindUniqueArgs extends PostAttachmentFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PostAttachment findUniqueOrThrow
   */
  export type PostAttachmentFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PostAttachment
     * 
    **/
    select?: PostAttachmentSelect | null
    /**
     * Filter, which PostAttachment to fetch.
     * 
    **/
    where: PostAttachmentWhereUniqueInput
  }


  /**
   * PostAttachment base type for findFirst actions
   */
  export type PostAttachmentFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the PostAttachment
     * 
    **/
    select?: PostAttachmentSelect | null
    /**
     * Filter, which PostAttachment to fetch.
     * 
    **/
    where?: PostAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostAttachments to fetch.
     * 
    **/
    orderBy?: Enumerable<PostAttachmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostAttachments.
     * 
    **/
    cursor?: PostAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostAttachments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostAttachments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostAttachments.
     * 
    **/
    distinct?: Enumerable<PostAttachmentScalarFieldEnum>
  }

  /**
   * PostAttachment: findFirst
   */
  export interface PostAttachmentFindFirstArgs extends PostAttachmentFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * PostAttachment findFirstOrThrow
   */
  export type PostAttachmentFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the PostAttachment
     * 
    **/
    select?: PostAttachmentSelect | null
    /**
     * Filter, which PostAttachment to fetch.
     * 
    **/
    where?: PostAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostAttachments to fetch.
     * 
    **/
    orderBy?: Enumerable<PostAttachmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostAttachments.
     * 
    **/
    cursor?: PostAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostAttachments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostAttachments.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostAttachments.
     * 
    **/
    distinct?: Enumerable<PostAttachmentScalarFieldEnum>
  }


  /**
   * PostAttachment findMany
   */
  export type PostAttachmentFindManyArgs = {
    /**
     * Select specific fields to fetch from the PostAttachment
     * 
    **/
    select?: PostAttachmentSelect | null
    /**
     * Filter, which PostAttachments to fetch.
     * 
    **/
    where?: PostAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostAttachments to fetch.
     * 
    **/
    orderBy?: Enumerable<PostAttachmentOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostAttachments.
     * 
    **/
    cursor?: PostAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostAttachments from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostAttachments.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PostAttachmentScalarFieldEnum>
  }


  /**
   * PostAttachment create
   */
  export type PostAttachmentCreateArgs = {
    /**
     * Select specific fields to fetch from the PostAttachment
     * 
    **/
    select?: PostAttachmentSelect | null
    /**
     * The data needed to create a PostAttachment.
     * 
    **/
    data: XOR<PostAttachmentCreateInput, PostAttachmentUncheckedCreateInput>
  }


  /**
   * PostAttachment createMany
   */
  export type PostAttachmentCreateManyArgs = {
    /**
     * The data used to create many PostAttachments.
     * 
    **/
    data: Enumerable<PostAttachmentCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PostAttachment update
   */
  export type PostAttachmentUpdateArgs = {
    /**
     * Select specific fields to fetch from the PostAttachment
     * 
    **/
    select?: PostAttachmentSelect | null
    /**
     * The data needed to update a PostAttachment.
     * 
    **/
    data: XOR<PostAttachmentUpdateInput, PostAttachmentUncheckedUpdateInput>
    /**
     * Choose, which PostAttachment to update.
     * 
    **/
    where: PostAttachmentWhereUniqueInput
  }


  /**
   * PostAttachment updateMany
   */
  export type PostAttachmentUpdateManyArgs = {
    /**
     * The data used to update PostAttachments.
     * 
    **/
    data: XOR<PostAttachmentUpdateManyMutationInput, PostAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which PostAttachments to update
     * 
    **/
    where?: PostAttachmentWhereInput
  }


  /**
   * PostAttachment upsert
   */
  export type PostAttachmentUpsertArgs = {
    /**
     * Select specific fields to fetch from the PostAttachment
     * 
    **/
    select?: PostAttachmentSelect | null
    /**
     * The filter to search for the PostAttachment to update in case it exists.
     * 
    **/
    where: PostAttachmentWhereUniqueInput
    /**
     * In case the PostAttachment found by the `where` argument doesn't exist, create a new PostAttachment with this data.
     * 
    **/
    create: XOR<PostAttachmentCreateInput, PostAttachmentUncheckedCreateInput>
    /**
     * In case the PostAttachment was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PostAttachmentUpdateInput, PostAttachmentUncheckedUpdateInput>
  }


  /**
   * PostAttachment delete
   */
  export type PostAttachmentDeleteArgs = {
    /**
     * Select specific fields to fetch from the PostAttachment
     * 
    **/
    select?: PostAttachmentSelect | null
    /**
     * Filter which PostAttachment to delete.
     * 
    **/
    where: PostAttachmentWhereUniqueInput
  }


  /**
   * PostAttachment deleteMany
   */
  export type PostAttachmentDeleteManyArgs = {
    /**
     * Filter which PostAttachments to delete
     * 
    **/
    where?: PostAttachmentWhereInput
  }


  /**
   * PostAttachment without action
   */
  export type PostAttachmentArgs = {
    /**
     * Select specific fields to fetch from the PostAttachment
     * 
    **/
    select?: PostAttachmentSelect | null
  }



  /**
   * Model Friendship
   */


  export type AggregateFriendship = {
    _count: FriendshipCountAggregateOutputType | null
    _avg: FriendshipAvgAggregateOutputType | null
    _sum: FriendshipSumAggregateOutputType | null
    _min: FriendshipMinAggregateOutputType | null
    _max: FriendshipMaxAggregateOutputType | null
  }

  export type FriendshipAvgAggregateOutputType = {
    id: number | null
    fromId: number | null
    toId: number | null
  }

  export type FriendshipSumAggregateOutputType = {
    id: number | null
    fromId: number | null
    toId: number | null
  }

  export type FriendshipMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: FriendshipStatus | null
    fromId: number | null
    toId: number | null
  }

  export type FriendshipMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    status: FriendshipStatus | null
    fromId: number | null
    toId: number | null
  }

  export type FriendshipCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    status: number
    fromId: number
    toId: number
    _all: number
  }


  export type FriendshipAvgAggregateInputType = {
    id?: true
    fromId?: true
    toId?: true
  }

  export type FriendshipSumAggregateInputType = {
    id?: true
    fromId?: true
    toId?: true
  }

  export type FriendshipMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    fromId?: true
    toId?: true
  }

  export type FriendshipMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    fromId?: true
    toId?: true
  }

  export type FriendshipCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    fromId?: true
    toId?: true
    _all?: true
  }

  export type FriendshipAggregateArgs = {
    /**
     * Filter which Friendship to aggregate.
     * 
    **/
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     * 
    **/
    orderBy?: Enumerable<FriendshipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Friendships
    **/
    _count?: true | FriendshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FriendshipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FriendshipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FriendshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FriendshipMaxAggregateInputType
  }

  export type GetFriendshipAggregateType<T extends FriendshipAggregateArgs> = {
        [P in keyof T & keyof AggregateFriendship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFriendship[P]>
      : GetScalarType<T[P], AggregateFriendship[P]>
  }




  export type FriendshipGroupByArgs = {
    where?: FriendshipWhereInput
    orderBy?: Enumerable<FriendshipOrderByWithAggregationInput>
    by: Array<FriendshipScalarFieldEnum>
    having?: FriendshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FriendshipCountAggregateInputType | true
    _avg?: FriendshipAvgAggregateInputType
    _sum?: FriendshipSumAggregateInputType
    _min?: FriendshipMinAggregateInputType
    _max?: FriendshipMaxAggregateInputType
  }


  export type FriendshipGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    status: FriendshipStatus
    fromId: number
    toId: number
    _count: FriendshipCountAggregateOutputType | null
    _avg: FriendshipAvgAggregateOutputType | null
    _sum: FriendshipSumAggregateOutputType | null
    _min: FriendshipMinAggregateOutputType | null
    _max: FriendshipMaxAggregateOutputType | null
  }

  type GetFriendshipGroupByPayload<T extends FriendshipGroupByArgs> = PrismaPromise<
    Array<
      PickArray<FriendshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FriendshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FriendshipGroupByOutputType[P]>
            : GetScalarType<T[P], FriendshipGroupByOutputType[P]>
        }
      >
    >


  export type FriendshipSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    from?: boolean | UserArgs
    to?: boolean | UserArgs
    status?: boolean
    fromId?: boolean
    toId?: boolean
    Notification?: boolean | NotificationFindManyArgs
    _count?: boolean | FriendshipCountOutputTypeArgs
  }


  export type FriendshipInclude = {
    from?: boolean | UserArgs
    to?: boolean | UserArgs
    Notification?: boolean | NotificationFindManyArgs
    _count?: boolean | FriendshipCountOutputTypeArgs
  } 

  export type FriendshipGetPayload<S extends boolean | null | undefined | FriendshipArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Friendship :
    S extends undefined ? never :
    S extends { include: any } & (FriendshipArgs | FriendshipFindManyArgs)
    ? Friendship  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'from' ? UserGetPayload<S['include'][P]> :
        P extends 'to' ? UserGetPayload<S['include'][P]> :
        P extends 'Notification' ? Array < NotificationGetPayload<S['include'][P]>>  :
        P extends '_count' ? FriendshipCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (FriendshipArgs | FriendshipFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'from' ? UserGetPayload<S['select'][P]> :
        P extends 'to' ? UserGetPayload<S['select'][P]> :
        P extends 'Notification' ? Array < NotificationGetPayload<S['select'][P]>>  :
        P extends '_count' ? FriendshipCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Friendship ? Friendship[P] : never
  } 
      : Friendship


  type FriendshipCountArgs = Merge<
    Omit<FriendshipFindManyArgs, 'select' | 'include'> & {
      select?: FriendshipCountAggregateInputType | true
    }
  >

  export interface FriendshipDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Friendship that matches the filter.
     * @param {FriendshipFindUniqueArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FriendshipFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FriendshipFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Friendship'> extends True ? Prisma__FriendshipClient<FriendshipGetPayload<T>> : Prisma__FriendshipClient<FriendshipGetPayload<T> | null, null>

    /**
     * Find one Friendship that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FriendshipFindUniqueOrThrowArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FriendshipFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, FriendshipFindUniqueOrThrowArgs>
    ): Prisma__FriendshipClient<FriendshipGetPayload<T>>

    /**
     * Find the first Friendship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipFindFirstArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FriendshipFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FriendshipFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Friendship'> extends True ? Prisma__FriendshipClient<FriendshipGetPayload<T>> : Prisma__FriendshipClient<FriendshipGetPayload<T> | null, null>

    /**
     * Find the first Friendship that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipFindFirstOrThrowArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FriendshipFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FriendshipFindFirstOrThrowArgs>
    ): Prisma__FriendshipClient<FriendshipGetPayload<T>>

    /**
     * Find zero or more Friendships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Friendships
     * const friendships = await prisma.friendship.findMany()
     * 
     * // Get first 10 Friendships
     * const friendships = await prisma.friendship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const friendshipWithIdOnly = await prisma.friendship.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FriendshipFindManyArgs>(
      args?: SelectSubset<T, FriendshipFindManyArgs>
    ): PrismaPromise<Array<FriendshipGetPayload<T>>>

    /**
     * Create a Friendship.
     * @param {FriendshipCreateArgs} args - Arguments to create a Friendship.
     * @example
     * // Create one Friendship
     * const Friendship = await prisma.friendship.create({
     *   data: {
     *     // ... data to create a Friendship
     *   }
     * })
     * 
    **/
    create<T extends FriendshipCreateArgs>(
      args: SelectSubset<T, FriendshipCreateArgs>
    ): Prisma__FriendshipClient<FriendshipGetPayload<T>>

    /**
     * Create many Friendships.
     *     @param {FriendshipCreateManyArgs} args - Arguments to create many Friendships.
     *     @example
     *     // Create many Friendships
     *     const friendship = await prisma.friendship.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FriendshipCreateManyArgs>(
      args?: SelectSubset<T, FriendshipCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Friendship.
     * @param {FriendshipDeleteArgs} args - Arguments to delete one Friendship.
     * @example
     * // Delete one Friendship
     * const Friendship = await prisma.friendship.delete({
     *   where: {
     *     // ... filter to delete one Friendship
     *   }
     * })
     * 
    **/
    delete<T extends FriendshipDeleteArgs>(
      args: SelectSubset<T, FriendshipDeleteArgs>
    ): Prisma__FriendshipClient<FriendshipGetPayload<T>>

    /**
     * Update one Friendship.
     * @param {FriendshipUpdateArgs} args - Arguments to update one Friendship.
     * @example
     * // Update one Friendship
     * const friendship = await prisma.friendship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FriendshipUpdateArgs>(
      args: SelectSubset<T, FriendshipUpdateArgs>
    ): Prisma__FriendshipClient<FriendshipGetPayload<T>>

    /**
     * Delete zero or more Friendships.
     * @param {FriendshipDeleteManyArgs} args - Arguments to filter Friendships to delete.
     * @example
     * // Delete a few Friendships
     * const { count } = await prisma.friendship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FriendshipDeleteManyArgs>(
      args?: SelectSubset<T, FriendshipDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Friendships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Friendships
     * const friendship = await prisma.friendship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FriendshipUpdateManyArgs>(
      args: SelectSubset<T, FriendshipUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Friendship.
     * @param {FriendshipUpsertArgs} args - Arguments to update or create a Friendship.
     * @example
     * // Update or create a Friendship
     * const friendship = await prisma.friendship.upsert({
     *   create: {
     *     // ... data to create a Friendship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Friendship we want to update
     *   }
     * })
    **/
    upsert<T extends FriendshipUpsertArgs>(
      args: SelectSubset<T, FriendshipUpsertArgs>
    ): Prisma__FriendshipClient<FriendshipGetPayload<T>>

    /**
     * Count the number of Friendships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipCountArgs} args - Arguments to filter Friendships to count.
     * @example
     * // Count the number of Friendships
     * const count = await prisma.friendship.count({
     *   where: {
     *     // ... the filter for the Friendships we want to count
     *   }
     * })
    **/
    count<T extends FriendshipCountArgs>(
      args?: Subset<T, FriendshipCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FriendshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Friendship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FriendshipAggregateArgs>(args: Subset<T, FriendshipAggregateArgs>): PrismaPromise<GetFriendshipAggregateType<T>>

    /**
     * Group by Friendship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FriendshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FriendshipGroupByArgs['orderBy'] }
        : { orderBy?: FriendshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FriendshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFriendshipGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Friendship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FriendshipClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    from<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    to<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    Notification<T extends NotificationFindManyArgs= {}>(args?: Subset<T, NotificationFindManyArgs>): PrismaPromise<Array<NotificationGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Friendship base type for findUnique actions
   */
  export type FriendshipFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Friendship
     * 
    **/
    select?: FriendshipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FriendshipInclude | null
    /**
     * Filter, which Friendship to fetch.
     * 
    **/
    where: FriendshipWhereUniqueInput
  }

  /**
   * Friendship: findUnique
   */
  export interface FriendshipFindUniqueArgs extends FriendshipFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Friendship findUniqueOrThrow
   */
  export type FriendshipFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Friendship
     * 
    **/
    select?: FriendshipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FriendshipInclude | null
    /**
     * Filter, which Friendship to fetch.
     * 
    **/
    where: FriendshipWhereUniqueInput
  }


  /**
   * Friendship base type for findFirst actions
   */
  export type FriendshipFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Friendship
     * 
    **/
    select?: FriendshipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FriendshipInclude | null
    /**
     * Filter, which Friendship to fetch.
     * 
    **/
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     * 
    **/
    orderBy?: Enumerable<FriendshipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Friendships.
     * 
    **/
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Friendships.
     * 
    **/
    distinct?: Enumerable<FriendshipScalarFieldEnum>
  }

  /**
   * Friendship: findFirst
   */
  export interface FriendshipFindFirstArgs extends FriendshipFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Friendship findFirstOrThrow
   */
  export type FriendshipFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Friendship
     * 
    **/
    select?: FriendshipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FriendshipInclude | null
    /**
     * Filter, which Friendship to fetch.
     * 
    **/
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     * 
    **/
    orderBy?: Enumerable<FriendshipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Friendships.
     * 
    **/
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Friendships.
     * 
    **/
    distinct?: Enumerable<FriendshipScalarFieldEnum>
  }


  /**
   * Friendship findMany
   */
  export type FriendshipFindManyArgs = {
    /**
     * Select specific fields to fetch from the Friendship
     * 
    **/
    select?: FriendshipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FriendshipInclude | null
    /**
     * Filter, which Friendships to fetch.
     * 
    **/
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     * 
    **/
    orderBy?: Enumerable<FriendshipOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Friendships.
     * 
    **/
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     * 
    **/
    skip?: number
    distinct?: Enumerable<FriendshipScalarFieldEnum>
  }


  /**
   * Friendship create
   */
  export type FriendshipCreateArgs = {
    /**
     * Select specific fields to fetch from the Friendship
     * 
    **/
    select?: FriendshipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FriendshipInclude | null
    /**
     * The data needed to create a Friendship.
     * 
    **/
    data: XOR<FriendshipCreateInput, FriendshipUncheckedCreateInput>
  }


  /**
   * Friendship createMany
   */
  export type FriendshipCreateManyArgs = {
    /**
     * The data used to create many Friendships.
     * 
    **/
    data: Enumerable<FriendshipCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Friendship update
   */
  export type FriendshipUpdateArgs = {
    /**
     * Select specific fields to fetch from the Friendship
     * 
    **/
    select?: FriendshipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FriendshipInclude | null
    /**
     * The data needed to update a Friendship.
     * 
    **/
    data: XOR<FriendshipUpdateInput, FriendshipUncheckedUpdateInput>
    /**
     * Choose, which Friendship to update.
     * 
    **/
    where: FriendshipWhereUniqueInput
  }


  /**
   * Friendship updateMany
   */
  export type FriendshipUpdateManyArgs = {
    /**
     * The data used to update Friendships.
     * 
    **/
    data: XOR<FriendshipUpdateManyMutationInput, FriendshipUncheckedUpdateManyInput>
    /**
     * Filter which Friendships to update
     * 
    **/
    where?: FriendshipWhereInput
  }


  /**
   * Friendship upsert
   */
  export type FriendshipUpsertArgs = {
    /**
     * Select specific fields to fetch from the Friendship
     * 
    **/
    select?: FriendshipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FriendshipInclude | null
    /**
     * The filter to search for the Friendship to update in case it exists.
     * 
    **/
    where: FriendshipWhereUniqueInput
    /**
     * In case the Friendship found by the `where` argument doesn't exist, create a new Friendship with this data.
     * 
    **/
    create: XOR<FriendshipCreateInput, FriendshipUncheckedCreateInput>
    /**
     * In case the Friendship was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<FriendshipUpdateInput, FriendshipUncheckedUpdateInput>
  }


  /**
   * Friendship delete
   */
  export type FriendshipDeleteArgs = {
    /**
     * Select specific fields to fetch from the Friendship
     * 
    **/
    select?: FriendshipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FriendshipInclude | null
    /**
     * Filter which Friendship to delete.
     * 
    **/
    where: FriendshipWhereUniqueInput
  }


  /**
   * Friendship deleteMany
   */
  export type FriendshipDeleteManyArgs = {
    /**
     * Filter which Friendships to delete
     * 
    **/
    where?: FriendshipWhereInput
  }


  /**
   * Friendship without action
   */
  export type FriendshipArgs = {
    /**
     * Select specific fields to fetch from the Friendship
     * 
    **/
    select?: FriendshipSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FriendshipInclude | null
  }



  /**
   * Model Conversation
   */


  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _avg: ConversationAvgAggregateOutputType | null
    _sum: ConversationSumAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationAvgAggregateOutputType = {
    id: number | null
    fromId: number | null
    toId: number | null
  }

  export type ConversationSumAggregateOutputType = {
    id: number | null
    fromId: number | null
    toId: number | null
  }

  export type ConversationMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    fromId: number | null
    toId: number | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    fromId: number | null
    toId: number | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    fromId: number
    toId: number
    _all: number
  }


  export type ConversationAvgAggregateInputType = {
    id?: true
    fromId?: true
    toId?: true
  }

  export type ConversationSumAggregateInputType = {
    id?: true
    fromId?: true
    toId?: true
  }

  export type ConversationMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    fromId?: true
    toId?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    fromId?: true
    toId?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    fromId?: true
    toId?: true
    _all?: true
  }

  export type ConversationAggregateArgs = {
    /**
     * Filter which Conversation to aggregate.
     * 
    **/
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     * 
    **/
    orderBy?: Enumerable<ConversationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConversationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConversationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type ConversationGroupByArgs = {
    where?: ConversationWhereInput
    orderBy?: Enumerable<ConversationOrderByWithAggregationInput>
    by: Array<ConversationScalarFieldEnum>
    having?: ConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _avg?: ConversationAvgAggregateInputType
    _sum?: ConversationSumAggregateInputType
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }


  export type ConversationGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    fromId: number
    toId: number | null
    _count: ConversationCountAggregateOutputType | null
    _avg: ConversationAvgAggregateOutputType | null
    _sum: ConversationSumAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends ConversationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type ConversationSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    From?: boolean | UserArgs
    fromId?: boolean
    To?: boolean | UserArgs
    toId?: boolean
    Messages?: boolean | ConversationMessageFindManyArgs
    _count?: boolean | ConversationCountOutputTypeArgs
  }


  export type ConversationInclude = {
    From?: boolean | UserArgs
    To?: boolean | UserArgs
    Messages?: boolean | ConversationMessageFindManyArgs
    _count?: boolean | ConversationCountOutputTypeArgs
  } 

  export type ConversationGetPayload<S extends boolean | null | undefined | ConversationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Conversation :
    S extends undefined ? never :
    S extends { include: any } & (ConversationArgs | ConversationFindManyArgs)
    ? Conversation  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'From' ? UserGetPayload<S['include'][P]> :
        P extends 'To' ? UserGetPayload<S['include'][P]> | null :
        P extends 'Messages' ? Array < ConversationMessageGetPayload<S['include'][P]>>  :
        P extends '_count' ? ConversationCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ConversationArgs | ConversationFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'From' ? UserGetPayload<S['select'][P]> :
        P extends 'To' ? UserGetPayload<S['select'][P]> | null :
        P extends 'Messages' ? Array < ConversationMessageGetPayload<S['select'][P]>>  :
        P extends '_count' ? ConversationCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Conversation ? Conversation[P] : never
  } 
      : Conversation


  type ConversationCountArgs = Merge<
    Omit<ConversationFindManyArgs, 'select' | 'include'> & {
      select?: ConversationCountAggregateInputType | true
    }
  >

  export interface ConversationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {ConversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConversationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ConversationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Conversation'> extends True ? Prisma__ConversationClient<ConversationGetPayload<T>> : Prisma__ConversationClient<ConversationGetPayload<T> | null, null>

    /**
     * Find one Conversation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ConversationFindUniqueOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ConversationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ConversationFindUniqueOrThrowArgs>
    ): Prisma__ConversationClient<ConversationGetPayload<T>>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConversationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ConversationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Conversation'> extends True ? Prisma__ConversationClient<ConversationGetPayload<T>> : Prisma__ConversationClient<ConversationGetPayload<T> | null, null>

    /**
     * Find the first Conversation that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ConversationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ConversationFindFirstOrThrowArgs>
    ): Prisma__ConversationClient<ConversationGetPayload<T>>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ConversationFindManyArgs>(
      args?: SelectSubset<T, ConversationFindManyArgs>
    ): PrismaPromise<Array<ConversationGetPayload<T>>>

    /**
     * Create a Conversation.
     * @param {ConversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
    **/
    create<T extends ConversationCreateArgs>(
      args: SelectSubset<T, ConversationCreateArgs>
    ): Prisma__ConversationClient<ConversationGetPayload<T>>

    /**
     * Create many Conversations.
     *     @param {ConversationCreateManyArgs} args - Arguments to create many Conversations.
     *     @example
     *     // Create many Conversations
     *     const conversation = await prisma.conversation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConversationCreateManyArgs>(
      args?: SelectSubset<T, ConversationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Conversation.
     * @param {ConversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
    **/
    delete<T extends ConversationDeleteArgs>(
      args: SelectSubset<T, ConversationDeleteArgs>
    ): Prisma__ConversationClient<ConversationGetPayload<T>>

    /**
     * Update one Conversation.
     * @param {ConversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConversationUpdateArgs>(
      args: SelectSubset<T, ConversationUpdateArgs>
    ): Prisma__ConversationClient<ConversationGetPayload<T>>

    /**
     * Delete zero or more Conversations.
     * @param {ConversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConversationDeleteManyArgs>(
      args?: SelectSubset<T, ConversationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConversationUpdateManyArgs>(
      args: SelectSubset<T, ConversationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Conversation.
     * @param {ConversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
    **/
    upsert<T extends ConversationUpsertArgs>(
      args: SelectSubset<T, ConversationUpsertArgs>
    ): Prisma__ConversationClient<ConversationGetPayload<T>>

    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends ConversationCountArgs>(
      args?: Subset<T, ConversationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationGroupByArgs['orderBy'] }
        : { orderBy?: ConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ConversationClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    From<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    To<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    Messages<T extends ConversationMessageFindManyArgs= {}>(args?: Subset<T, ConversationMessageFindManyArgs>): PrismaPromise<Array<ConversationMessageGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Conversation base type for findUnique actions
   */
  export type ConversationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Conversation
     * 
    **/
    select?: ConversationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConversationInclude | null
    /**
     * Filter, which Conversation to fetch.
     * 
    **/
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation: findUnique
   */
  export interface ConversationFindUniqueArgs extends ConversationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Conversation findUniqueOrThrow
   */
  export type ConversationFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Conversation
     * 
    **/
    select?: ConversationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConversationInclude | null
    /**
     * Filter, which Conversation to fetch.
     * 
    **/
    where: ConversationWhereUniqueInput
  }


  /**
   * Conversation base type for findFirst actions
   */
  export type ConversationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Conversation
     * 
    **/
    select?: ConversationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConversationInclude | null
    /**
     * Filter, which Conversation to fetch.
     * 
    **/
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     * 
    **/
    orderBy?: Enumerable<ConversationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     * 
    **/
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     * 
    **/
    distinct?: Enumerable<ConversationScalarFieldEnum>
  }

  /**
   * Conversation: findFirst
   */
  export interface ConversationFindFirstArgs extends ConversationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Conversation findFirstOrThrow
   */
  export type ConversationFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Conversation
     * 
    **/
    select?: ConversationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConversationInclude | null
    /**
     * Filter, which Conversation to fetch.
     * 
    **/
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     * 
    **/
    orderBy?: Enumerable<ConversationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     * 
    **/
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     * 
    **/
    distinct?: Enumerable<ConversationScalarFieldEnum>
  }


  /**
   * Conversation findMany
   */
  export type ConversationFindManyArgs = {
    /**
     * Select specific fields to fetch from the Conversation
     * 
    **/
    select?: ConversationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConversationInclude | null
    /**
     * Filter, which Conversations to fetch.
     * 
    **/
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     * 
    **/
    orderBy?: Enumerable<ConversationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversations.
     * 
    **/
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ConversationScalarFieldEnum>
  }


  /**
   * Conversation create
   */
  export type ConversationCreateArgs = {
    /**
     * Select specific fields to fetch from the Conversation
     * 
    **/
    select?: ConversationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConversationInclude | null
    /**
     * The data needed to create a Conversation.
     * 
    **/
    data: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
  }


  /**
   * Conversation createMany
   */
  export type ConversationCreateManyArgs = {
    /**
     * The data used to create many Conversations.
     * 
    **/
    data: Enumerable<ConversationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Conversation update
   */
  export type ConversationUpdateArgs = {
    /**
     * Select specific fields to fetch from the Conversation
     * 
    **/
    select?: ConversationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConversationInclude | null
    /**
     * The data needed to update a Conversation.
     * 
    **/
    data: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
    /**
     * Choose, which Conversation to update.
     * 
    **/
    where: ConversationWhereUniqueInput
  }


  /**
   * Conversation updateMany
   */
  export type ConversationUpdateManyArgs = {
    /**
     * The data used to update Conversations.
     * 
    **/
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     * 
    **/
    where?: ConversationWhereInput
  }


  /**
   * Conversation upsert
   */
  export type ConversationUpsertArgs = {
    /**
     * Select specific fields to fetch from the Conversation
     * 
    **/
    select?: ConversationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConversationInclude | null
    /**
     * The filter to search for the Conversation to update in case it exists.
     * 
    **/
    where: ConversationWhereUniqueInput
    /**
     * In case the Conversation found by the `where` argument doesn't exist, create a new Conversation with this data.
     * 
    **/
    create: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
    /**
     * In case the Conversation was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
  }


  /**
   * Conversation delete
   */
  export type ConversationDeleteArgs = {
    /**
     * Select specific fields to fetch from the Conversation
     * 
    **/
    select?: ConversationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConversationInclude | null
    /**
     * Filter which Conversation to delete.
     * 
    **/
    where: ConversationWhereUniqueInput
  }


  /**
   * Conversation deleteMany
   */
  export type ConversationDeleteManyArgs = {
    /**
     * Filter which Conversations to delete
     * 
    **/
    where?: ConversationWhereInput
  }


  /**
   * Conversation without action
   */
  export type ConversationArgs = {
    /**
     * Select specific fields to fetch from the Conversation
     * 
    **/
    select?: ConversationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConversationInclude | null
  }



  /**
   * Model ConversationMessage
   */


  export type AggregateConversationMessage = {
    _count: ConversationMessageCountAggregateOutputType | null
    _avg: ConversationMessageAvgAggregateOutputType | null
    _sum: ConversationMessageSumAggregateOutputType | null
    _min: ConversationMessageMinAggregateOutputType | null
    _max: ConversationMessageMaxAggregateOutputType | null
  }

  export type ConversationMessageAvgAggregateOutputType = {
    id: number | null
    conversationId: number | null
    userId: number | null
  }

  export type ConversationMessageSumAggregateOutputType = {
    id: number | null
    conversationId: number | null
    userId: number | null
  }

  export type ConversationMessageMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    conversationId: number | null
    userId: number | null
  }

  export type ConversationMessageMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    conversationId: number | null
    userId: number | null
  }

  export type ConversationMessageCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    conversationId: number
    userId: number
    _all: number
  }


  export type ConversationMessageAvgAggregateInputType = {
    id?: true
    conversationId?: true
    userId?: true
  }

  export type ConversationMessageSumAggregateInputType = {
    id?: true
    conversationId?: true
    userId?: true
  }

  export type ConversationMessageMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    conversationId?: true
    userId?: true
  }

  export type ConversationMessageMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    conversationId?: true
    userId?: true
  }

  export type ConversationMessageCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    conversationId?: true
    userId?: true
    _all?: true
  }

  export type ConversationMessageAggregateArgs = {
    /**
     * Filter which ConversationMessage to aggregate.
     * 
    **/
    where?: ConversationMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationMessages to fetch.
     * 
    **/
    orderBy?: Enumerable<ConversationMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ConversationMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationMessages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationMessages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConversationMessages
    **/
    _count?: true | ConversationMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConversationMessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConversationMessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMessageMaxAggregateInputType
  }

  export type GetConversationMessageAggregateType<T extends ConversationMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateConversationMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversationMessage[P]>
      : GetScalarType<T[P], AggregateConversationMessage[P]>
  }




  export type ConversationMessageGroupByArgs = {
    where?: ConversationMessageWhereInput
    orderBy?: Enumerable<ConversationMessageOrderByWithAggregationInput>
    by: Array<ConversationMessageScalarFieldEnum>
    having?: ConversationMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationMessageCountAggregateInputType | true
    _avg?: ConversationMessageAvgAggregateInputType
    _sum?: ConversationMessageSumAggregateInputType
    _min?: ConversationMessageMinAggregateInputType
    _max?: ConversationMessageMaxAggregateInputType
  }


  export type ConversationMessageGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    conversationId: number | null
    userId: number
    _count: ConversationMessageCountAggregateOutputType | null
    _avg: ConversationMessageAvgAggregateOutputType | null
    _sum: ConversationMessageSumAggregateOutputType | null
    _min: ConversationMessageMinAggregateOutputType | null
    _max: ConversationMessageMaxAggregateOutputType | null
  }

  type GetConversationMessageGroupByPayload<T extends ConversationMessageGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ConversationMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationMessageGroupByOutputType[P]>
        }
      >
    >


  export type ConversationMessageSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Conversation?: boolean | ConversationArgs
    conversationId?: boolean
    From?: boolean | UserArgs
    userId?: boolean
    Notification?: boolean | NotificationFindManyArgs
    _count?: boolean | ConversationMessageCountOutputTypeArgs
  }


  export type ConversationMessageInclude = {
    Conversation?: boolean | ConversationArgs
    From?: boolean | UserArgs
    Notification?: boolean | NotificationFindManyArgs
    _count?: boolean | ConversationMessageCountOutputTypeArgs
  } 

  export type ConversationMessageGetPayload<S extends boolean | null | undefined | ConversationMessageArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ConversationMessage :
    S extends undefined ? never :
    S extends { include: any } & (ConversationMessageArgs | ConversationMessageFindManyArgs)
    ? ConversationMessage  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Conversation' ? ConversationGetPayload<S['include'][P]> | null :
        P extends 'From' ? UserGetPayload<S['include'][P]> :
        P extends 'Notification' ? Array < NotificationGetPayload<S['include'][P]>>  :
        P extends '_count' ? ConversationMessageCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ConversationMessageArgs | ConversationMessageFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Conversation' ? ConversationGetPayload<S['select'][P]> | null :
        P extends 'From' ? UserGetPayload<S['select'][P]> :
        P extends 'Notification' ? Array < NotificationGetPayload<S['select'][P]>>  :
        P extends '_count' ? ConversationMessageCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof ConversationMessage ? ConversationMessage[P] : never
  } 
      : ConversationMessage


  type ConversationMessageCountArgs = Merge<
    Omit<ConversationMessageFindManyArgs, 'select' | 'include'> & {
      select?: ConversationMessageCountAggregateInputType | true
    }
  >

  export interface ConversationMessageDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one ConversationMessage that matches the filter.
     * @param {ConversationMessageFindUniqueArgs} args - Arguments to find a ConversationMessage
     * @example
     * // Get one ConversationMessage
     * const conversationMessage = await prisma.conversationMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConversationMessageFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ConversationMessageFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ConversationMessage'> extends True ? Prisma__ConversationMessageClient<ConversationMessageGetPayload<T>> : Prisma__ConversationMessageClient<ConversationMessageGetPayload<T> | null, null>

    /**
     * Find one ConversationMessage that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ConversationMessageFindUniqueOrThrowArgs} args - Arguments to find a ConversationMessage
     * @example
     * // Get one ConversationMessage
     * const conversationMessage = await prisma.conversationMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ConversationMessageFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ConversationMessageFindUniqueOrThrowArgs>
    ): Prisma__ConversationMessageClient<ConversationMessageGetPayload<T>>

    /**
     * Find the first ConversationMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMessageFindFirstArgs} args - Arguments to find a ConversationMessage
     * @example
     * // Get one ConversationMessage
     * const conversationMessage = await prisma.conversationMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConversationMessageFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ConversationMessageFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ConversationMessage'> extends True ? Prisma__ConversationMessageClient<ConversationMessageGetPayload<T>> : Prisma__ConversationMessageClient<ConversationMessageGetPayload<T> | null, null>

    /**
     * Find the first ConversationMessage that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMessageFindFirstOrThrowArgs} args - Arguments to find a ConversationMessage
     * @example
     * // Get one ConversationMessage
     * const conversationMessage = await prisma.conversationMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ConversationMessageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ConversationMessageFindFirstOrThrowArgs>
    ): Prisma__ConversationMessageClient<ConversationMessageGetPayload<T>>

    /**
     * Find zero or more ConversationMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConversationMessages
     * const conversationMessages = await prisma.conversationMessage.findMany()
     * 
     * // Get first 10 ConversationMessages
     * const conversationMessages = await prisma.conversationMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationMessageWithIdOnly = await prisma.conversationMessage.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ConversationMessageFindManyArgs>(
      args?: SelectSubset<T, ConversationMessageFindManyArgs>
    ): PrismaPromise<Array<ConversationMessageGetPayload<T>>>

    /**
     * Create a ConversationMessage.
     * @param {ConversationMessageCreateArgs} args - Arguments to create a ConversationMessage.
     * @example
     * // Create one ConversationMessage
     * const ConversationMessage = await prisma.conversationMessage.create({
     *   data: {
     *     // ... data to create a ConversationMessage
     *   }
     * })
     * 
    **/
    create<T extends ConversationMessageCreateArgs>(
      args: SelectSubset<T, ConversationMessageCreateArgs>
    ): Prisma__ConversationMessageClient<ConversationMessageGetPayload<T>>

    /**
     * Create many ConversationMessages.
     *     @param {ConversationMessageCreateManyArgs} args - Arguments to create many ConversationMessages.
     *     @example
     *     // Create many ConversationMessages
     *     const conversationMessage = await prisma.conversationMessage.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConversationMessageCreateManyArgs>(
      args?: SelectSubset<T, ConversationMessageCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a ConversationMessage.
     * @param {ConversationMessageDeleteArgs} args - Arguments to delete one ConversationMessage.
     * @example
     * // Delete one ConversationMessage
     * const ConversationMessage = await prisma.conversationMessage.delete({
     *   where: {
     *     // ... filter to delete one ConversationMessage
     *   }
     * })
     * 
    **/
    delete<T extends ConversationMessageDeleteArgs>(
      args: SelectSubset<T, ConversationMessageDeleteArgs>
    ): Prisma__ConversationMessageClient<ConversationMessageGetPayload<T>>

    /**
     * Update one ConversationMessage.
     * @param {ConversationMessageUpdateArgs} args - Arguments to update one ConversationMessage.
     * @example
     * // Update one ConversationMessage
     * const conversationMessage = await prisma.conversationMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConversationMessageUpdateArgs>(
      args: SelectSubset<T, ConversationMessageUpdateArgs>
    ): Prisma__ConversationMessageClient<ConversationMessageGetPayload<T>>

    /**
     * Delete zero or more ConversationMessages.
     * @param {ConversationMessageDeleteManyArgs} args - Arguments to filter ConversationMessages to delete.
     * @example
     * // Delete a few ConversationMessages
     * const { count } = await prisma.conversationMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConversationMessageDeleteManyArgs>(
      args?: SelectSubset<T, ConversationMessageDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConversationMessages
     * const conversationMessage = await prisma.conversationMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConversationMessageUpdateManyArgs>(
      args: SelectSubset<T, ConversationMessageUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one ConversationMessage.
     * @param {ConversationMessageUpsertArgs} args - Arguments to update or create a ConversationMessage.
     * @example
     * // Update or create a ConversationMessage
     * const conversationMessage = await prisma.conversationMessage.upsert({
     *   create: {
     *     // ... data to create a ConversationMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConversationMessage we want to update
     *   }
     * })
    **/
    upsert<T extends ConversationMessageUpsertArgs>(
      args: SelectSubset<T, ConversationMessageUpsertArgs>
    ): Prisma__ConversationMessageClient<ConversationMessageGetPayload<T>>

    /**
     * Count the number of ConversationMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMessageCountArgs} args - Arguments to filter ConversationMessages to count.
     * @example
     * // Count the number of ConversationMessages
     * const count = await prisma.conversationMessage.count({
     *   where: {
     *     // ... the filter for the ConversationMessages we want to count
     *   }
     * })
    **/
    count<T extends ConversationMessageCountArgs>(
      args?: Subset<T, ConversationMessageCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConversationMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationMessageAggregateArgs>(args: Subset<T, ConversationMessageAggregateArgs>): PrismaPromise<GetConversationMessageAggregateType<T>>

    /**
     * Group by ConversationMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationMessageGroupByArgs['orderBy'] }
        : { orderBy?: ConversationMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationMessageGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ConversationMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ConversationMessageClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Conversation<T extends ConversationArgs= {}>(args?: Subset<T, ConversationArgs>): Prisma__ConversationClient<ConversationGetPayload<T> | Null>;

    From<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    Notification<T extends NotificationFindManyArgs= {}>(args?: Subset<T, NotificationFindManyArgs>): PrismaPromise<Array<NotificationGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ConversationMessage base type for findUnique actions
   */
  export type ConversationMessageFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     * 
    **/
    select?: ConversationMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConversationMessageInclude | null
    /**
     * Filter, which ConversationMessage to fetch.
     * 
    **/
    where: ConversationMessageWhereUniqueInput
  }

  /**
   * ConversationMessage: findUnique
   */
  export interface ConversationMessageFindUniqueArgs extends ConversationMessageFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ConversationMessage findUniqueOrThrow
   */
  export type ConversationMessageFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     * 
    **/
    select?: ConversationMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConversationMessageInclude | null
    /**
     * Filter, which ConversationMessage to fetch.
     * 
    **/
    where: ConversationMessageWhereUniqueInput
  }


  /**
   * ConversationMessage base type for findFirst actions
   */
  export type ConversationMessageFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     * 
    **/
    select?: ConversationMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConversationMessageInclude | null
    /**
     * Filter, which ConversationMessage to fetch.
     * 
    **/
    where?: ConversationMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationMessages to fetch.
     * 
    **/
    orderBy?: Enumerable<ConversationMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationMessages.
     * 
    **/
    cursor?: ConversationMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationMessages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationMessages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationMessages.
     * 
    **/
    distinct?: Enumerable<ConversationMessageScalarFieldEnum>
  }

  /**
   * ConversationMessage: findFirst
   */
  export interface ConversationMessageFindFirstArgs extends ConversationMessageFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ConversationMessage findFirstOrThrow
   */
  export type ConversationMessageFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     * 
    **/
    select?: ConversationMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConversationMessageInclude | null
    /**
     * Filter, which ConversationMessage to fetch.
     * 
    **/
    where?: ConversationMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationMessages to fetch.
     * 
    **/
    orderBy?: Enumerable<ConversationMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationMessages.
     * 
    **/
    cursor?: ConversationMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationMessages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationMessages.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationMessages.
     * 
    **/
    distinct?: Enumerable<ConversationMessageScalarFieldEnum>
  }


  /**
   * ConversationMessage findMany
   */
  export type ConversationMessageFindManyArgs = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     * 
    **/
    select?: ConversationMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConversationMessageInclude | null
    /**
     * Filter, which ConversationMessages to fetch.
     * 
    **/
    where?: ConversationMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationMessages to fetch.
     * 
    **/
    orderBy?: Enumerable<ConversationMessageOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConversationMessages.
     * 
    **/
    cursor?: ConversationMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationMessages from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationMessages.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ConversationMessageScalarFieldEnum>
  }


  /**
   * ConversationMessage create
   */
  export type ConversationMessageCreateArgs = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     * 
    **/
    select?: ConversationMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConversationMessageInclude | null
    /**
     * The data needed to create a ConversationMessage.
     * 
    **/
    data: XOR<ConversationMessageCreateInput, ConversationMessageUncheckedCreateInput>
  }


  /**
   * ConversationMessage createMany
   */
  export type ConversationMessageCreateManyArgs = {
    /**
     * The data used to create many ConversationMessages.
     * 
    **/
    data: Enumerable<ConversationMessageCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ConversationMessage update
   */
  export type ConversationMessageUpdateArgs = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     * 
    **/
    select?: ConversationMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConversationMessageInclude | null
    /**
     * The data needed to update a ConversationMessage.
     * 
    **/
    data: XOR<ConversationMessageUpdateInput, ConversationMessageUncheckedUpdateInput>
    /**
     * Choose, which ConversationMessage to update.
     * 
    **/
    where: ConversationMessageWhereUniqueInput
  }


  /**
   * ConversationMessage updateMany
   */
  export type ConversationMessageUpdateManyArgs = {
    /**
     * The data used to update ConversationMessages.
     * 
    **/
    data: XOR<ConversationMessageUpdateManyMutationInput, ConversationMessageUncheckedUpdateManyInput>
    /**
     * Filter which ConversationMessages to update
     * 
    **/
    where?: ConversationMessageWhereInput
  }


  /**
   * ConversationMessage upsert
   */
  export type ConversationMessageUpsertArgs = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     * 
    **/
    select?: ConversationMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConversationMessageInclude | null
    /**
     * The filter to search for the ConversationMessage to update in case it exists.
     * 
    **/
    where: ConversationMessageWhereUniqueInput
    /**
     * In case the ConversationMessage found by the `where` argument doesn't exist, create a new ConversationMessage with this data.
     * 
    **/
    create: XOR<ConversationMessageCreateInput, ConversationMessageUncheckedCreateInput>
    /**
     * In case the ConversationMessage was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ConversationMessageUpdateInput, ConversationMessageUncheckedUpdateInput>
  }


  /**
   * ConversationMessage delete
   */
  export type ConversationMessageDeleteArgs = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     * 
    **/
    select?: ConversationMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConversationMessageInclude | null
    /**
     * Filter which ConversationMessage to delete.
     * 
    **/
    where: ConversationMessageWhereUniqueInput
  }


  /**
   * ConversationMessage deleteMany
   */
  export type ConversationMessageDeleteManyArgs = {
    /**
     * Filter which ConversationMessages to delete
     * 
    **/
    where?: ConversationMessageWhereInput
  }


  /**
   * ConversationMessage without action
   */
  export type ConversationMessageArgs = {
    /**
     * Select specific fields to fetch from the ConversationMessage
     * 
    **/
    select?: ConversationMessageSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ConversationMessageInclude | null
  }



  /**
   * Model Notification
   */


  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
    friendshipId: number | null
    conversationMessageId: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
    friendshipId: number | null
    conversationMessageId: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    read: boolean | null
    friendshipId: number | null
    conversationMessageId: number | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    read: boolean | null
    friendshipId: number | null
    conversationMessageId: number | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    read: number
    friendshipId: number
    conversationMessageId: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
    friendshipId?: true
    conversationMessageId?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
    friendshipId?: true
    conversationMessageId?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    read?: true
    friendshipId?: true
    conversationMessageId?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    read?: true
    friendshipId?: true
    conversationMessageId?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    read?: true
    friendshipId?: true
    conversationMessageId?: true
    _all?: true
  }

  export type NotificationAggregateArgs = {
    /**
     * Filter which Notification to aggregate.
     * 
    **/
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     * 
    **/
    orderBy?: Enumerable<NotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs = {
    where?: NotificationWhereInput
    orderBy?: Enumerable<NotificationOrderByWithAggregationInput>
    by: Array<NotificationScalarFieldEnum>
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }


  export type NotificationGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    read: boolean
    friendshipId: number | null
    conversationMessageId: number | null
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = PrismaPromise<
    Array<
      PickArray<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    read?: boolean
    Friendship?: boolean | FriendshipArgs
    friendshipId?: boolean
    Message?: boolean | ConversationMessageArgs
    conversationMessageId?: boolean
  }


  export type NotificationInclude = {
    Friendship?: boolean | FriendshipArgs
    Message?: boolean | ConversationMessageArgs
  } 

  export type NotificationGetPayload<S extends boolean | null | undefined | NotificationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Notification :
    S extends undefined ? never :
    S extends { include: any } & (NotificationArgs | NotificationFindManyArgs)
    ? Notification  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'Friendship' ? FriendshipGetPayload<S['include'][P]> | null :
        P extends 'Message' ? ConversationMessageGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (NotificationArgs | NotificationFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'Friendship' ? FriendshipGetPayload<S['select'][P]> | null :
        P extends 'Message' ? ConversationMessageGetPayload<S['select'][P]> | null :  P extends keyof Notification ? Notification[P] : never
  } 
      : Notification


  type NotificationCountArgs = Merge<
    Omit<NotificationFindManyArgs, 'select' | 'include'> & {
      select?: NotificationCountAggregateInputType | true
    }
  >

  export interface NotificationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NotificationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NotificationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Notification'> extends True ? Prisma__NotificationClient<NotificationGetPayload<T>> : Prisma__NotificationClient<NotificationGetPayload<T> | null, null>

    /**
     * Find one Notification that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, NotificationFindUniqueOrThrowArgs>
    ): Prisma__NotificationClient<NotificationGetPayload<T>>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NotificationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NotificationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Notification'> extends True ? Prisma__NotificationClient<NotificationGetPayload<T>> : Prisma__NotificationClient<NotificationGetPayload<T> | null, null>

    /**
     * Find the first Notification that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NotificationFindFirstOrThrowArgs>
    ): Prisma__NotificationClient<NotificationGetPayload<T>>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NotificationFindManyArgs>(
      args?: SelectSubset<T, NotificationFindManyArgs>
    ): PrismaPromise<Array<NotificationGetPayload<T>>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
    **/
    create<T extends NotificationCreateArgs>(
      args: SelectSubset<T, NotificationCreateArgs>
    ): Prisma__NotificationClient<NotificationGetPayload<T>>

    /**
     * Create many Notifications.
     *     @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     *     @example
     *     // Create many Notifications
     *     const notification = await prisma.notification.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NotificationCreateManyArgs>(
      args?: SelectSubset<T, NotificationCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
    **/
    delete<T extends NotificationDeleteArgs>(
      args: SelectSubset<T, NotificationDeleteArgs>
    ): Prisma__NotificationClient<NotificationGetPayload<T>>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NotificationUpdateArgs>(
      args: SelectSubset<T, NotificationUpdateArgs>
    ): Prisma__NotificationClient<NotificationGetPayload<T>>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NotificationDeleteManyArgs>(
      args?: SelectSubset<T, NotificationDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NotificationUpdateManyArgs>(
      args: SelectSubset<T, NotificationUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
    **/
    upsert<T extends NotificationUpsertArgs>(
      args: SelectSubset<T, NotificationUpsertArgs>
    ): Prisma__NotificationClient<NotificationGetPayload<T>>

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NotificationClient<T, Null = never> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Friendship<T extends FriendshipArgs= {}>(args?: Subset<T, FriendshipArgs>): Prisma__FriendshipClient<FriendshipGetPayload<T> | Null>;

    Message<T extends ConversationMessageArgs= {}>(args?: Subset<T, ConversationMessageArgs>): Prisma__ConversationMessageClient<ConversationMessageGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Notification base type for findUnique actions
   */
  export type NotificationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * Filter, which Notification to fetch.
     * 
    **/
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification: findUnique
   */
  export interface NotificationFindUniqueArgs extends NotificationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * Filter, which Notification to fetch.
     * 
    **/
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification base type for findFirst actions
   */
  export type NotificationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * Filter, which Notification to fetch.
     * 
    **/
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     * 
    **/
    orderBy?: Enumerable<NotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     * 
    **/
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     * 
    **/
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }

  /**
   * Notification: findFirst
   */
  export interface NotificationFindFirstArgs extends NotificationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * Filter, which Notification to fetch.
     * 
    **/
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     * 
    **/
    orderBy?: Enumerable<NotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     * 
    **/
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     * 
    **/
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }


  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * Filter, which Notifications to fetch.
     * 
    **/
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     * 
    **/
    orderBy?: Enumerable<NotificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     * 
    **/
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     * 
    **/
    skip?: number
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }


  /**
   * Notification create
   */
  export type NotificationCreateArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * The data needed to create a Notification.
     * 
    **/
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }


  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs = {
    /**
     * The data used to create many Notifications.
     * 
    **/
    data: Enumerable<NotificationCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Notification update
   */
  export type NotificationUpdateArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * The data needed to update a Notification.
     * 
    **/
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     * 
    **/
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs = {
    /**
     * The data used to update Notifications.
     * 
    **/
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     * 
    **/
    where?: NotificationWhereInput
  }


  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * The filter to search for the Notification to update in case it exists.
     * 
    **/
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     * 
    **/
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }


  /**
   * Notification delete
   */
  export type NotificationDeleteArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
    /**
     * Filter which Notification to delete.
     * 
    **/
    where: NotificationWhereUniqueInput
  }


  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs = {
    /**
     * Filter which Notifications to delete
     * 
    **/
    where?: NotificationWhereInput
  }


  /**
   * Notification without action
   */
  export type NotificationArgs = {
    /**
     * Select specific fields to fetch from the Notification
     * 
    **/
    select?: NotificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NotificationInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const ConversationMessageScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    conversationId: 'conversationId',
    userId: 'userId'
  };

  export type ConversationMessageScalarFieldEnum = (typeof ConversationMessageScalarFieldEnum)[keyof typeof ConversationMessageScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    fromId: 'fromId',
    toId: 'toId'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const FriendshipScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status',
    fromId: 'fromId',
    toId: 'toId'
  };

  export type FriendshipScalarFieldEnum = (typeof FriendshipScalarFieldEnum)[keyof typeof FriendshipScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    read: 'read',
    friendshipId: 'friendshipId',
    conversationMessageId: 'conversationMessageId'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const PostAttachmentScalarFieldEnum: {
    id: 'id',
    type: 'type',
    s3Key: 's3Key'
  };

  export type PostAttachmentScalarFieldEnum = (typeof PostAttachmentScalarFieldEnum)[keyof typeof PostAttachmentScalarFieldEnum]


  export const PostCommentScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    postId: 'postId',
    text: 'text'
  };

  export type PostCommentScalarFieldEnum = (typeof PostCommentScalarFieldEnum)[keyof typeof PostCommentScalarFieldEnum]


  export const PostLikeScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    postId: 'postId'
  };

  export type PostLikeScalarFieldEnum = (typeof PostLikeScalarFieldEnum)[keyof typeof PostLikeScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    htmlContent: 'htmlContent',
    userId: 'userId'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    firstname: 'firstname',
    lastname: 'lastname',
    email: 'email',
    avatarS3Key: 'avatarS3Key',
    coverPicS3Key: 'coverPicS3Key'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    firstname?: StringFilter | string
    lastname?: StringFilter | string
    email?: StringFilter | string
    avatarS3Key?: StringFilter | string
    coverPicS3Key?: StringFilter | string
    Posts?: PostListRelationFilter
    PostLikes?: PostLikeListRelationFilter
    PostComment?: PostCommentListRelationFilter
    FromFriendship?: FriendshipListRelationFilter
    ToFrienship?: FriendshipListRelationFilter
    BlockedUsers?: UserListRelationFilter
    BlockedByUsers?: UserListRelationFilter
    ConversationsSent?: ConversationListRelationFilter
    ConversationsReceived?: ConversationListRelationFilter
    ConversationMessages?: ConversationMessageListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    avatarS3Key?: SortOrder
    coverPicS3Key?: SortOrder
    Posts?: PostOrderByRelationAggregateInput
    PostLikes?: PostLikeOrderByRelationAggregateInput
    PostComment?: PostCommentOrderByRelationAggregateInput
    FromFriendship?: FriendshipOrderByRelationAggregateInput
    ToFrienship?: FriendshipOrderByRelationAggregateInput
    BlockedUsers?: UserOrderByRelationAggregateInput
    BlockedByUsers?: UserOrderByRelationAggregateInput
    ConversationsSent?: ConversationOrderByRelationAggregateInput
    ConversationsReceived?: ConversationOrderByRelationAggregateInput
    ConversationMessages?: ConversationMessageOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: number
    email?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    avatarS3Key?: SortOrder
    coverPicS3Key?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    firstname?: StringWithAggregatesFilter | string
    lastname?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    avatarS3Key?: StringWithAggregatesFilter | string
    coverPicS3Key?: StringWithAggregatesFilter | string
  }

  export type PostWhereInput = {
    AND?: Enumerable<PostWhereInput>
    OR?: Enumerable<PostWhereInput>
    NOT?: Enumerable<PostWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    htmlContent?: StringFilter | string
    User?: XOR<UserRelationFilter, UserWhereInput>
    userId?: IntFilter | number
    PostLikes?: PostLikeListRelationFilter
    PostComments?: PostCommentListRelationFilter
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    htmlContent?: SortOrder
    User?: UserOrderByWithRelationInput
    userId?: SortOrder
    PostLikes?: PostLikeOrderByRelationAggregateInput
    PostComments?: PostCommentOrderByRelationAggregateInput
  }

  export type PostWhereUniqueInput = {
    id?: number
  }

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    htmlContent?: SortOrder
    userId?: SortOrder
    _count?: PostCountOrderByAggregateInput
    _avg?: PostAvgOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
    _sum?: PostSumOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PostScalarWhereWithAggregatesInput>
    OR?: Enumerable<PostScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PostScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    htmlContent?: StringWithAggregatesFilter | string
    userId?: IntWithAggregatesFilter | number
  }

  export type PostLikeWhereInput = {
    AND?: Enumerable<PostLikeWhereInput>
    OR?: Enumerable<PostLikeWhereInput>
    NOT?: Enumerable<PostLikeWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    User?: XOR<UserRelationFilter, UserWhereInput>
    Post?: XOR<PostRelationFilter, PostWhereInput>
    userId?: IntFilter | number
    postId?: IntFilter | number
  }

  export type PostLikeOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    User?: UserOrderByWithRelationInput
    Post?: PostOrderByWithRelationInput
    userId?: SortOrder
    postId?: SortOrder
  }

  export type PostLikeWhereUniqueInput = {
    id?: number
  }

  export type PostLikeOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    _count?: PostLikeCountOrderByAggregateInput
    _avg?: PostLikeAvgOrderByAggregateInput
    _max?: PostLikeMaxOrderByAggregateInput
    _min?: PostLikeMinOrderByAggregateInput
    _sum?: PostLikeSumOrderByAggregateInput
  }

  export type PostLikeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PostLikeScalarWhereWithAggregatesInput>
    OR?: Enumerable<PostLikeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PostLikeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    userId?: IntWithAggregatesFilter | number
    postId?: IntWithAggregatesFilter | number
  }

  export type PostCommentWhereInput = {
    AND?: Enumerable<PostCommentWhereInput>
    OR?: Enumerable<PostCommentWhereInput>
    NOT?: Enumerable<PostCommentWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    User?: XOR<UserRelationFilter, UserWhereInput>
    Post?: XOR<PostRelationFilter, PostWhereInput>
    userId?: IntFilter | number
    postId?: IntFilter | number
    text?: StringFilter | string
  }

  export type PostCommentOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    User?: UserOrderByWithRelationInput
    Post?: PostOrderByWithRelationInput
    userId?: SortOrder
    postId?: SortOrder
    text?: SortOrder
  }

  export type PostCommentWhereUniqueInput = {
    id?: number
  }

  export type PostCommentOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    text?: SortOrder
    _count?: PostCommentCountOrderByAggregateInput
    _avg?: PostCommentAvgOrderByAggregateInput
    _max?: PostCommentMaxOrderByAggregateInput
    _min?: PostCommentMinOrderByAggregateInput
    _sum?: PostCommentSumOrderByAggregateInput
  }

  export type PostCommentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PostCommentScalarWhereWithAggregatesInput>
    OR?: Enumerable<PostCommentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PostCommentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    userId?: IntWithAggregatesFilter | number
    postId?: IntWithAggregatesFilter | number
    text?: StringWithAggregatesFilter | string
  }

  export type PostAttachmentWhereInput = {
    AND?: Enumerable<PostAttachmentWhereInput>
    OR?: Enumerable<PostAttachmentWhereInput>
    NOT?: Enumerable<PostAttachmentWhereInput>
    id?: IntFilter | number
    type?: EnumDocumentTypeFilter | DocumentType
    s3Key?: StringFilter | string
  }

  export type PostAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    s3Key?: SortOrder
  }

  export type PostAttachmentWhereUniqueInput = {
    id?: number
  }

  export type PostAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    s3Key?: SortOrder
    _count?: PostAttachmentCountOrderByAggregateInput
    _avg?: PostAttachmentAvgOrderByAggregateInput
    _max?: PostAttachmentMaxOrderByAggregateInput
    _min?: PostAttachmentMinOrderByAggregateInput
    _sum?: PostAttachmentSumOrderByAggregateInput
  }

  export type PostAttachmentScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PostAttachmentScalarWhereWithAggregatesInput>
    OR?: Enumerable<PostAttachmentScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PostAttachmentScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    type?: EnumDocumentTypeWithAggregatesFilter | DocumentType
    s3Key?: StringWithAggregatesFilter | string
  }

  export type FriendshipWhereInput = {
    AND?: Enumerable<FriendshipWhereInput>
    OR?: Enumerable<FriendshipWhereInput>
    NOT?: Enumerable<FriendshipWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    from?: XOR<UserRelationFilter, UserWhereInput>
    to?: XOR<UserRelationFilter, UserWhereInput>
    status?: EnumFriendshipStatusFilter | FriendshipStatus
    fromId?: IntFilter | number
    toId?: IntFilter | number
    Notification?: NotificationListRelationFilter
  }

  export type FriendshipOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    from?: UserOrderByWithRelationInput
    to?: UserOrderByWithRelationInput
    status?: SortOrder
    fromId?: SortOrder
    toId?: SortOrder
    Notification?: NotificationOrderByRelationAggregateInput
  }

  export type FriendshipWhereUniqueInput = {
    id?: number
  }

  export type FriendshipOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    fromId?: SortOrder
    toId?: SortOrder
    _count?: FriendshipCountOrderByAggregateInput
    _avg?: FriendshipAvgOrderByAggregateInput
    _max?: FriendshipMaxOrderByAggregateInput
    _min?: FriendshipMinOrderByAggregateInput
    _sum?: FriendshipSumOrderByAggregateInput
  }

  export type FriendshipScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FriendshipScalarWhereWithAggregatesInput>
    OR?: Enumerable<FriendshipScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FriendshipScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    status?: EnumFriendshipStatusWithAggregatesFilter | FriendshipStatus
    fromId?: IntWithAggregatesFilter | number
    toId?: IntWithAggregatesFilter | number
  }

  export type ConversationWhereInput = {
    AND?: Enumerable<ConversationWhereInput>
    OR?: Enumerable<ConversationWhereInput>
    NOT?: Enumerable<ConversationWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    From?: XOR<UserRelationFilter, UserWhereInput>
    fromId?: IntFilter | number
    To?: XOR<UserRelationFilter, UserWhereInput> | null
    toId?: IntNullableFilter | number | null
    Messages?: ConversationMessageListRelationFilter
  }

  export type ConversationOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    From?: UserOrderByWithRelationInput
    fromId?: SortOrder
    To?: UserOrderByWithRelationInput
    toId?: SortOrder
    Messages?: ConversationMessageOrderByRelationAggregateInput
  }

  export type ConversationWhereUniqueInput = {
    id?: number
  }

  export type ConversationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fromId?: SortOrder
    toId?: SortOrder
    _count?: ConversationCountOrderByAggregateInput
    _avg?: ConversationAvgOrderByAggregateInput
    _max?: ConversationMaxOrderByAggregateInput
    _min?: ConversationMinOrderByAggregateInput
    _sum?: ConversationSumOrderByAggregateInput
  }

  export type ConversationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ConversationScalarWhereWithAggregatesInput>
    OR?: Enumerable<ConversationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ConversationScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    fromId?: IntWithAggregatesFilter | number
    toId?: IntNullableWithAggregatesFilter | number | null
  }

  export type ConversationMessageWhereInput = {
    AND?: Enumerable<ConversationMessageWhereInput>
    OR?: Enumerable<ConversationMessageWhereInput>
    NOT?: Enumerable<ConversationMessageWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    Conversation?: XOR<ConversationRelationFilter, ConversationWhereInput> | null
    conversationId?: IntNullableFilter | number | null
    From?: XOR<UserRelationFilter, UserWhereInput>
    userId?: IntFilter | number
    Notification?: NotificationListRelationFilter
  }

  export type ConversationMessageOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Conversation?: ConversationOrderByWithRelationInput
    conversationId?: SortOrder
    From?: UserOrderByWithRelationInput
    userId?: SortOrder
    Notification?: NotificationOrderByRelationAggregateInput
  }

  export type ConversationMessageWhereUniqueInput = {
    id?: number
  }

  export type ConversationMessageOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
    _count?: ConversationMessageCountOrderByAggregateInput
    _avg?: ConversationMessageAvgOrderByAggregateInput
    _max?: ConversationMessageMaxOrderByAggregateInput
    _min?: ConversationMessageMinOrderByAggregateInput
    _sum?: ConversationMessageSumOrderByAggregateInput
  }

  export type ConversationMessageScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ConversationMessageScalarWhereWithAggregatesInput>
    OR?: Enumerable<ConversationMessageScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ConversationMessageScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    conversationId?: IntNullableWithAggregatesFilter | number | null
    userId?: IntWithAggregatesFilter | number
  }

  export type NotificationWhereInput = {
    AND?: Enumerable<NotificationWhereInput>
    OR?: Enumerable<NotificationWhereInput>
    NOT?: Enumerable<NotificationWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    read?: BoolFilter | boolean
    Friendship?: XOR<FriendshipRelationFilter, FriendshipWhereInput> | null
    friendshipId?: IntNullableFilter | number | null
    Message?: XOR<ConversationMessageRelationFilter, ConversationMessageWhereInput> | null
    conversationMessageId?: IntNullableFilter | number | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    read?: SortOrder
    Friendship?: FriendshipOrderByWithRelationInput
    friendshipId?: SortOrder
    Message?: ConversationMessageOrderByWithRelationInput
    conversationMessageId?: SortOrder
  }

  export type NotificationWhereUniqueInput = {
    id?: number
  }

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    read?: SortOrder
    friendshipId?: SortOrder
    conversationMessageId?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NotificationScalarWhereWithAggregatesInput>
    OR?: Enumerable<NotificationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NotificationScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    read?: BoolWithAggregatesFilter | boolean
    friendshipId?: IntNullableWithAggregatesFilter | number | null
    conversationMessageId?: IntNullableWithAggregatesFilter | number | null
  }

  export type UserCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    firstname: string
    lastname: string
    email: string
    avatarS3Key: string
    coverPicS3Key: string
    Posts?: PostCreateNestedManyWithoutUserInput
    PostLikes?: PostLikeCreateNestedManyWithoutUserInput
    PostComment?: PostCommentCreateNestedManyWithoutUserInput
    FromFriendship?: FriendshipCreateNestedManyWithoutFromInput
    ToFrienship?: FriendshipCreateNestedManyWithoutToInput
    BlockedUsers?: UserCreateNestedManyWithoutBlockedByUsersInput
    BlockedByUsers?: UserCreateNestedManyWithoutBlockedUsersInput
    ConversationsSent?: ConversationCreateNestedManyWithoutFromInput
    ConversationsReceived?: ConversationCreateNestedManyWithoutToInput
    ConversationMessages?: ConversationMessageCreateNestedManyWithoutFromInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    firstname: string
    lastname: string
    email: string
    avatarS3Key: string
    coverPicS3Key: string
    Posts?: PostUncheckedCreateNestedManyWithoutUserInput
    PostLikes?: PostLikeUncheckedCreateNestedManyWithoutUserInput
    PostComment?: PostCommentUncheckedCreateNestedManyWithoutUserInput
    FromFriendship?: FriendshipUncheckedCreateNestedManyWithoutFromInput
    ToFrienship?: FriendshipUncheckedCreateNestedManyWithoutToInput
    BlockedUsers?: UserUncheckedCreateNestedManyWithoutBlockedByUsersInput
    BlockedByUsers?: UserUncheckedCreateNestedManyWithoutBlockedUsersInput
    ConversationsSent?: ConversationUncheckedCreateNestedManyWithoutFromInput
    ConversationsReceived?: ConversationUncheckedCreateNestedManyWithoutToInput
    ConversationMessages?: ConversationMessageUncheckedCreateNestedManyWithoutFromInput
  }

  export type UserUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatarS3Key?: StringFieldUpdateOperationsInput | string
    coverPicS3Key?: StringFieldUpdateOperationsInput | string
    Posts?: PostUpdateManyWithoutUserNestedInput
    PostLikes?: PostLikeUpdateManyWithoutUserNestedInput
    PostComment?: PostCommentUpdateManyWithoutUserNestedInput
    FromFriendship?: FriendshipUpdateManyWithoutFromNestedInput
    ToFrienship?: FriendshipUpdateManyWithoutToNestedInput
    BlockedUsers?: UserUpdateManyWithoutBlockedByUsersNestedInput
    BlockedByUsers?: UserUpdateManyWithoutBlockedUsersNestedInput
    ConversationsSent?: ConversationUpdateManyWithoutFromNestedInput
    ConversationsReceived?: ConversationUpdateManyWithoutToNestedInput
    ConversationMessages?: ConversationMessageUpdateManyWithoutFromNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatarS3Key?: StringFieldUpdateOperationsInput | string
    coverPicS3Key?: StringFieldUpdateOperationsInput | string
    Posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    PostLikes?: PostLikeUncheckedUpdateManyWithoutUserNestedInput
    PostComment?: PostCommentUncheckedUpdateManyWithoutUserNestedInput
    FromFriendship?: FriendshipUncheckedUpdateManyWithoutFromNestedInput
    ToFrienship?: FriendshipUncheckedUpdateManyWithoutToNestedInput
    BlockedUsers?: UserUncheckedUpdateManyWithoutBlockedByUsersNestedInput
    BlockedByUsers?: UserUncheckedUpdateManyWithoutBlockedUsersNestedInput
    ConversationsSent?: ConversationUncheckedUpdateManyWithoutFromNestedInput
    ConversationsReceived?: ConversationUncheckedUpdateManyWithoutToNestedInput
    ConversationMessages?: ConversationMessageUncheckedUpdateManyWithoutFromNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    firstname: string
    lastname: string
    email: string
    avatarS3Key: string
    coverPicS3Key: string
  }

  export type UserUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatarS3Key?: StringFieldUpdateOperationsInput | string
    coverPicS3Key?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatarS3Key?: StringFieldUpdateOperationsInput | string
    coverPicS3Key?: StringFieldUpdateOperationsInput | string
  }

  export type PostCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    htmlContent: string
    User: UserCreateNestedOneWithoutPostsInput
    PostLikes?: PostLikeCreateNestedManyWithoutPostInput
    PostComments?: PostCommentCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    htmlContent: string
    userId: number
    PostLikes?: PostLikeUncheckedCreateNestedManyWithoutPostInput
    PostComments?: PostCommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    htmlContent?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneRequiredWithoutPostsNestedInput
    PostLikes?: PostLikeUpdateManyWithoutPostNestedInput
    PostComments?: PostCommentUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    htmlContent?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    PostLikes?: PostLikeUncheckedUpdateManyWithoutPostNestedInput
    PostComments?: PostCommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    htmlContent: string
    userId: number
  }

  export type PostUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    htmlContent?: StringFieldUpdateOperationsInput | string
  }

  export type PostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    htmlContent?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type PostLikeCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutPostLikesInput
    Post: PostCreateNestedOneWithoutPostLikesInput
  }

  export type PostLikeUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    postId: number
  }

  export type PostLikeUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutPostLikesNestedInput
    Post?: PostUpdateOneRequiredWithoutPostLikesNestedInput
  }

  export type PostLikeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
  }

  export type PostLikeCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    postId: number
  }

  export type PostLikeUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostLikeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
  }

  export type PostCommentCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutPostCommentInput
    Post: PostCreateNestedOneWithoutPostCommentsInput
    text: string
  }

  export type PostCommentUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    postId: number
    text: string
  }

  export type PostCommentUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutPostCommentNestedInput
    Post?: PostUpdateOneRequiredWithoutPostCommentsNestedInput
    text?: StringFieldUpdateOperationsInput | string
  }

  export type PostCommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
  }

  export type PostCommentCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    postId: number
    text: string
  }

  export type PostCommentUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    text?: StringFieldUpdateOperationsInput | string
  }

  export type PostCommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
  }

  export type PostAttachmentCreateInput = {
    type: DocumentType
    s3Key: string
  }

  export type PostAttachmentUncheckedCreateInput = {
    id?: number
    type: DocumentType
    s3Key: string
  }

  export type PostAttachmentUpdateInput = {
    type?: EnumDocumentTypeFieldUpdateOperationsInput | DocumentType
    s3Key?: StringFieldUpdateOperationsInput | string
  }

  export type PostAttachmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumDocumentTypeFieldUpdateOperationsInput | DocumentType
    s3Key?: StringFieldUpdateOperationsInput | string
  }

  export type PostAttachmentCreateManyInput = {
    id?: number
    type: DocumentType
    s3Key: string
  }

  export type PostAttachmentUpdateManyMutationInput = {
    type?: EnumDocumentTypeFieldUpdateOperationsInput | DocumentType
    s3Key?: StringFieldUpdateOperationsInput | string
  }

  export type PostAttachmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumDocumentTypeFieldUpdateOperationsInput | DocumentType
    s3Key?: StringFieldUpdateOperationsInput | string
  }

  export type FriendshipCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    from: UserCreateNestedOneWithoutFromFriendshipInput
    to: UserCreateNestedOneWithoutToFrienshipInput
    status?: FriendshipStatus
    Notification?: NotificationCreateNestedManyWithoutFriendshipInput
  }

  export type FriendshipUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: FriendshipStatus
    fromId: number
    toId: number
    Notification?: NotificationUncheckedCreateNestedManyWithoutFriendshipInput
  }

  export type FriendshipUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    from?: UserUpdateOneRequiredWithoutFromFriendshipNestedInput
    to?: UserUpdateOneRequiredWithoutToFrienshipNestedInput
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | FriendshipStatus
    Notification?: NotificationUpdateManyWithoutFriendshipNestedInput
  }

  export type FriendshipUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | FriendshipStatus
    fromId?: IntFieldUpdateOperationsInput | number
    toId?: IntFieldUpdateOperationsInput | number
    Notification?: NotificationUncheckedUpdateManyWithoutFriendshipNestedInput
  }

  export type FriendshipCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: FriendshipStatus
    fromId: number
    toId: number
  }

  export type FriendshipUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | FriendshipStatus
  }

  export type FriendshipUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | FriendshipStatus
    fromId?: IntFieldUpdateOperationsInput | number
    toId?: IntFieldUpdateOperationsInput | number
  }

  export type ConversationCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    From: UserCreateNestedOneWithoutConversationsSentInput
    To?: UserCreateNestedOneWithoutConversationsReceivedInput
    Messages?: ConversationMessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    fromId: number
    toId?: number | null
    Messages?: ConversationMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    From?: UserUpdateOneRequiredWithoutConversationsSentNestedInput
    To?: UserUpdateOneWithoutConversationsReceivedNestedInput
    Messages?: ConversationMessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromId?: IntFieldUpdateOperationsInput | number
    toId?: NullableIntFieldUpdateOperationsInput | number | null
    Messages?: ConversationMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    fromId: number
    toId?: number | null
  }

  export type ConversationUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromId?: IntFieldUpdateOperationsInput | number
    toId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ConversationMessageCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    Conversation?: ConversationCreateNestedOneWithoutMessagesInput
    From: UserCreateNestedOneWithoutConversationMessagesInput
    Notification?: NotificationCreateNestedManyWithoutMessageInput
  }

  export type ConversationMessageUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    conversationId?: number | null
    userId: number
    Notification?: NotificationUncheckedCreateNestedManyWithoutMessageInput
  }

  export type ConversationMessageUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Conversation?: ConversationUpdateOneWithoutMessagesNestedInput
    From?: UserUpdateOneRequiredWithoutConversationMessagesNestedInput
    Notification?: NotificationUpdateManyWithoutMessageNestedInput
  }

  export type ConversationMessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversationId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
    Notification?: NotificationUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type ConversationMessageCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    conversationId?: number | null
    userId: number
  }

  export type ConversationMessageUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationMessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversationId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type NotificationCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    read?: boolean
    Friendship?: FriendshipCreateNestedOneWithoutNotificationInput
    Message?: ConversationMessageCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    read?: boolean
    friendshipId?: number | null
    conversationMessageId?: number | null
  }

  export type NotificationUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    Friendship?: FriendshipUpdateOneWithoutNotificationNestedInput
    Message?: ConversationMessageUpdateOneWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    friendshipId?: NullableIntFieldUpdateOperationsInput | number | null
    conversationMessageId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NotificationCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    read?: boolean
    friendshipId?: number | null
    conversationMessageId?: number | null
  }

  export type NotificationUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    friendshipId?: NullableIntFieldUpdateOperationsInput | number | null
    conversationMessageId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type PostLikeListRelationFilter = {
    every?: PostLikeWhereInput
    some?: PostLikeWhereInput
    none?: PostLikeWhereInput
  }

  export type PostCommentListRelationFilter = {
    every?: PostCommentWhereInput
    some?: PostCommentWhereInput
    none?: PostCommentWhereInput
  }

  export type FriendshipListRelationFilter = {
    every?: FriendshipWhereInput
    some?: FriendshipWhereInput
    none?: FriendshipWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type ConversationListRelationFilter = {
    every?: ConversationWhereInput
    some?: ConversationWhereInput
    none?: ConversationWhereInput
  }

  export type ConversationMessageListRelationFilter = {
    every?: ConversationMessageWhereInput
    some?: ConversationMessageWhereInput
    none?: ConversationMessageWhereInput
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostLikeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FriendshipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    avatarS3Key?: SortOrder
    coverPicS3Key?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    avatarS3Key?: SortOrder
    coverPicS3Key?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    avatarS3Key?: SortOrder
    coverPicS3Key?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    htmlContent?: SortOrder
    userId?: SortOrder
  }

  export type PostAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    htmlContent?: SortOrder
    userId?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    htmlContent?: SortOrder
    userId?: SortOrder
  }

  export type PostSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PostRelationFilter = {
    is?: PostWhereInput
    isNot?: PostWhereInput
  }

  export type PostLikeCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
  }

  export type PostLikeAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
  }

  export type PostLikeMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
  }

  export type PostLikeMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
  }

  export type PostLikeSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
  }

  export type PostCommentCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    text?: SortOrder
  }

  export type PostCommentAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
  }

  export type PostCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    text?: SortOrder
  }

  export type PostCommentMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    text?: SortOrder
  }

  export type PostCommentSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
  }

  export type EnumDocumentTypeFilter = {
    equals?: DocumentType
    in?: Enumerable<DocumentType>
    notIn?: Enumerable<DocumentType>
    not?: NestedEnumDocumentTypeFilter | DocumentType
  }

  export type PostAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    s3Key?: SortOrder
  }

  export type PostAttachmentAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PostAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    s3Key?: SortOrder
  }

  export type PostAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    s3Key?: SortOrder
  }

  export type PostAttachmentSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumDocumentTypeWithAggregatesFilter = {
    equals?: DocumentType
    in?: Enumerable<DocumentType>
    notIn?: Enumerable<DocumentType>
    not?: NestedEnumDocumentTypeWithAggregatesFilter | DocumentType
    _count?: NestedIntFilter
    _min?: NestedEnumDocumentTypeFilter
    _max?: NestedEnumDocumentTypeFilter
  }

  export type EnumFriendshipStatusFilter = {
    equals?: FriendshipStatus
    in?: Enumerable<FriendshipStatus>
    notIn?: Enumerable<FriendshipStatus>
    not?: NestedEnumFriendshipStatusFilter | FriendshipStatus
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FriendshipCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    fromId?: SortOrder
    toId?: SortOrder
  }

  export type FriendshipAvgOrderByAggregateInput = {
    id?: SortOrder
    fromId?: SortOrder
    toId?: SortOrder
  }

  export type FriendshipMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    fromId?: SortOrder
    toId?: SortOrder
  }

  export type FriendshipMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    fromId?: SortOrder
    toId?: SortOrder
  }

  export type FriendshipSumOrderByAggregateInput = {
    id?: SortOrder
    fromId?: SortOrder
    toId?: SortOrder
  }

  export type EnumFriendshipStatusWithAggregatesFilter = {
    equals?: FriendshipStatus
    in?: Enumerable<FriendshipStatus>
    notIn?: Enumerable<FriendshipStatus>
    not?: NestedEnumFriendshipStatusWithAggregatesFilter | FriendshipStatus
    _count?: NestedIntFilter
    _min?: NestedEnumFriendshipStatusFilter
    _max?: NestedEnumFriendshipStatusFilter
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type ConversationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fromId?: SortOrder
    toId?: SortOrder
  }

  export type ConversationAvgOrderByAggregateInput = {
    id?: SortOrder
    fromId?: SortOrder
    toId?: SortOrder
  }

  export type ConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fromId?: SortOrder
    toId?: SortOrder
  }

  export type ConversationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    fromId?: SortOrder
    toId?: SortOrder
  }

  export type ConversationSumOrderByAggregateInput = {
    id?: SortOrder
    fromId?: SortOrder
    toId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type ConversationRelationFilter = {
    is?: ConversationWhereInput | null
    isNot?: ConversationWhereInput | null
  }

  export type ConversationMessageCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
  }

  export type ConversationMessageAvgOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
  }

  export type ConversationMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
  }

  export type ConversationMessageMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
  }

  export type ConversationMessageSumOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    userId?: SortOrder
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type FriendshipRelationFilter = {
    is?: FriendshipWhereInput | null
    isNot?: FriendshipWhereInput | null
  }

  export type ConversationMessageRelationFilter = {
    is?: ConversationMessageWhereInput | null
    isNot?: ConversationMessageWhereInput | null
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    read?: SortOrder
    friendshipId?: SortOrder
    conversationMessageId?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    friendshipId?: SortOrder
    conversationMessageId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    read?: SortOrder
    friendshipId?: SortOrder
    conversationMessageId?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    read?: SortOrder
    friendshipId?: SortOrder
    conversationMessageId?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    id?: SortOrder
    friendshipId?: SortOrder
    conversationMessageId?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type PostCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PostCreateWithoutUserInput>, Enumerable<PostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutUserInput>
    createMany?: PostCreateManyUserInputEnvelope
    connect?: Enumerable<PostWhereUniqueInput>
  }

  export type PostLikeCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PostLikeCreateWithoutUserInput>, Enumerable<PostLikeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PostLikeCreateOrConnectWithoutUserInput>
    createMany?: PostLikeCreateManyUserInputEnvelope
    connect?: Enumerable<PostLikeWhereUniqueInput>
  }

  export type PostCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PostCommentCreateWithoutUserInput>, Enumerable<PostCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PostCommentCreateOrConnectWithoutUserInput>
    createMany?: PostCommentCreateManyUserInputEnvelope
    connect?: Enumerable<PostCommentWhereUniqueInput>
  }

  export type FriendshipCreateNestedManyWithoutFromInput = {
    create?: XOR<Enumerable<FriendshipCreateWithoutFromInput>, Enumerable<FriendshipUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<FriendshipCreateOrConnectWithoutFromInput>
    createMany?: FriendshipCreateManyFromInputEnvelope
    connect?: Enumerable<FriendshipWhereUniqueInput>
  }

  export type FriendshipCreateNestedManyWithoutToInput = {
    create?: XOR<Enumerable<FriendshipCreateWithoutToInput>, Enumerable<FriendshipUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<FriendshipCreateOrConnectWithoutToInput>
    createMany?: FriendshipCreateManyToInputEnvelope
    connect?: Enumerable<FriendshipWhereUniqueInput>
  }

  export type UserCreateNestedManyWithoutBlockedByUsersInput = {
    create?: XOR<Enumerable<UserCreateWithoutBlockedByUsersInput>, Enumerable<UserUncheckedCreateWithoutBlockedByUsersInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutBlockedByUsersInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type UserCreateNestedManyWithoutBlockedUsersInput = {
    create?: XOR<Enumerable<UserCreateWithoutBlockedUsersInput>, Enumerable<UserUncheckedCreateWithoutBlockedUsersInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutBlockedUsersInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type ConversationCreateNestedManyWithoutFromInput = {
    create?: XOR<Enumerable<ConversationCreateWithoutFromInput>, Enumerable<ConversationUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<ConversationCreateOrConnectWithoutFromInput>
    createMany?: ConversationCreateManyFromInputEnvelope
    connect?: Enumerable<ConversationWhereUniqueInput>
  }

  export type ConversationCreateNestedManyWithoutToInput = {
    create?: XOR<Enumerable<ConversationCreateWithoutToInput>, Enumerable<ConversationUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<ConversationCreateOrConnectWithoutToInput>
    createMany?: ConversationCreateManyToInputEnvelope
    connect?: Enumerable<ConversationWhereUniqueInput>
  }

  export type ConversationMessageCreateNestedManyWithoutFromInput = {
    create?: XOR<Enumerable<ConversationMessageCreateWithoutFromInput>, Enumerable<ConversationMessageUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<ConversationMessageCreateOrConnectWithoutFromInput>
    createMany?: ConversationMessageCreateManyFromInputEnvelope
    connect?: Enumerable<ConversationMessageWhereUniqueInput>
  }

  export type PostUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PostCreateWithoutUserInput>, Enumerable<PostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutUserInput>
    createMany?: PostCreateManyUserInputEnvelope
    connect?: Enumerable<PostWhereUniqueInput>
  }

  export type PostLikeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PostLikeCreateWithoutUserInput>, Enumerable<PostLikeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PostLikeCreateOrConnectWithoutUserInput>
    createMany?: PostLikeCreateManyUserInputEnvelope
    connect?: Enumerable<PostLikeWhereUniqueInput>
  }

  export type PostCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<PostCommentCreateWithoutUserInput>, Enumerable<PostCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PostCommentCreateOrConnectWithoutUserInput>
    createMany?: PostCommentCreateManyUserInputEnvelope
    connect?: Enumerable<PostCommentWhereUniqueInput>
  }

  export type FriendshipUncheckedCreateNestedManyWithoutFromInput = {
    create?: XOR<Enumerable<FriendshipCreateWithoutFromInput>, Enumerable<FriendshipUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<FriendshipCreateOrConnectWithoutFromInput>
    createMany?: FriendshipCreateManyFromInputEnvelope
    connect?: Enumerable<FriendshipWhereUniqueInput>
  }

  export type FriendshipUncheckedCreateNestedManyWithoutToInput = {
    create?: XOR<Enumerable<FriendshipCreateWithoutToInput>, Enumerable<FriendshipUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<FriendshipCreateOrConnectWithoutToInput>
    createMany?: FriendshipCreateManyToInputEnvelope
    connect?: Enumerable<FriendshipWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutBlockedByUsersInput = {
    create?: XOR<Enumerable<UserCreateWithoutBlockedByUsersInput>, Enumerable<UserUncheckedCreateWithoutBlockedByUsersInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutBlockedByUsersInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type UserUncheckedCreateNestedManyWithoutBlockedUsersInput = {
    create?: XOR<Enumerable<UserCreateWithoutBlockedUsersInput>, Enumerable<UserUncheckedCreateWithoutBlockedUsersInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutBlockedUsersInput>
    connect?: Enumerable<UserWhereUniqueInput>
  }

  export type ConversationUncheckedCreateNestedManyWithoutFromInput = {
    create?: XOR<Enumerable<ConversationCreateWithoutFromInput>, Enumerable<ConversationUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<ConversationCreateOrConnectWithoutFromInput>
    createMany?: ConversationCreateManyFromInputEnvelope
    connect?: Enumerable<ConversationWhereUniqueInput>
  }

  export type ConversationUncheckedCreateNestedManyWithoutToInput = {
    create?: XOR<Enumerable<ConversationCreateWithoutToInput>, Enumerable<ConversationUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<ConversationCreateOrConnectWithoutToInput>
    createMany?: ConversationCreateManyToInputEnvelope
    connect?: Enumerable<ConversationWhereUniqueInput>
  }

  export type ConversationMessageUncheckedCreateNestedManyWithoutFromInput = {
    create?: XOR<Enumerable<ConversationMessageCreateWithoutFromInput>, Enumerable<ConversationMessageUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<ConversationMessageCreateOrConnectWithoutFromInput>
    createMany?: ConversationMessageCreateManyFromInputEnvelope
    connect?: Enumerable<ConversationMessageWhereUniqueInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type PostUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<PostCreateWithoutUserInput>, Enumerable<PostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PostUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PostCreateManyUserInputEnvelope
    set?: Enumerable<PostWhereUniqueInput>
    disconnect?: Enumerable<PostWhereUniqueInput>
    delete?: Enumerable<PostWhereUniqueInput>
    connect?: Enumerable<PostWhereUniqueInput>
    update?: Enumerable<PostUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PostUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PostScalarWhereInput>
  }

  export type PostLikeUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<PostLikeCreateWithoutUserInput>, Enumerable<PostLikeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PostLikeCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PostLikeUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PostLikeCreateManyUserInputEnvelope
    set?: Enumerable<PostLikeWhereUniqueInput>
    disconnect?: Enumerable<PostLikeWhereUniqueInput>
    delete?: Enumerable<PostLikeWhereUniqueInput>
    connect?: Enumerable<PostLikeWhereUniqueInput>
    update?: Enumerable<PostLikeUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PostLikeUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PostLikeScalarWhereInput>
  }

  export type PostCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<PostCommentCreateWithoutUserInput>, Enumerable<PostCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PostCommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PostCommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PostCommentCreateManyUserInputEnvelope
    set?: Enumerable<PostCommentWhereUniqueInput>
    disconnect?: Enumerable<PostCommentWhereUniqueInput>
    delete?: Enumerable<PostCommentWhereUniqueInput>
    connect?: Enumerable<PostCommentWhereUniqueInput>
    update?: Enumerable<PostCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PostCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PostCommentScalarWhereInput>
  }

  export type FriendshipUpdateManyWithoutFromNestedInput = {
    create?: XOR<Enumerable<FriendshipCreateWithoutFromInput>, Enumerable<FriendshipUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<FriendshipCreateOrConnectWithoutFromInput>
    upsert?: Enumerable<FriendshipUpsertWithWhereUniqueWithoutFromInput>
    createMany?: FriendshipCreateManyFromInputEnvelope
    set?: Enumerable<FriendshipWhereUniqueInput>
    disconnect?: Enumerable<FriendshipWhereUniqueInput>
    delete?: Enumerable<FriendshipWhereUniqueInput>
    connect?: Enumerable<FriendshipWhereUniqueInput>
    update?: Enumerable<FriendshipUpdateWithWhereUniqueWithoutFromInput>
    updateMany?: Enumerable<FriendshipUpdateManyWithWhereWithoutFromInput>
    deleteMany?: Enumerable<FriendshipScalarWhereInput>
  }

  export type FriendshipUpdateManyWithoutToNestedInput = {
    create?: XOR<Enumerable<FriendshipCreateWithoutToInput>, Enumerable<FriendshipUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<FriendshipCreateOrConnectWithoutToInput>
    upsert?: Enumerable<FriendshipUpsertWithWhereUniqueWithoutToInput>
    createMany?: FriendshipCreateManyToInputEnvelope
    set?: Enumerable<FriendshipWhereUniqueInput>
    disconnect?: Enumerable<FriendshipWhereUniqueInput>
    delete?: Enumerable<FriendshipWhereUniqueInput>
    connect?: Enumerable<FriendshipWhereUniqueInput>
    update?: Enumerable<FriendshipUpdateWithWhereUniqueWithoutToInput>
    updateMany?: Enumerable<FriendshipUpdateManyWithWhereWithoutToInput>
    deleteMany?: Enumerable<FriendshipScalarWhereInput>
  }

  export type UserUpdateManyWithoutBlockedByUsersNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutBlockedByUsersInput>, Enumerable<UserUncheckedCreateWithoutBlockedByUsersInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutBlockedByUsersInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutBlockedByUsersInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutBlockedByUsersInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutBlockedByUsersInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type UserUpdateManyWithoutBlockedUsersNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutBlockedUsersInput>, Enumerable<UserUncheckedCreateWithoutBlockedUsersInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutBlockedUsersInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutBlockedUsersInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutBlockedUsersInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutBlockedUsersInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type ConversationUpdateManyWithoutFromNestedInput = {
    create?: XOR<Enumerable<ConversationCreateWithoutFromInput>, Enumerable<ConversationUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<ConversationCreateOrConnectWithoutFromInput>
    upsert?: Enumerable<ConversationUpsertWithWhereUniqueWithoutFromInput>
    createMany?: ConversationCreateManyFromInputEnvelope
    set?: Enumerable<ConversationWhereUniqueInput>
    disconnect?: Enumerable<ConversationWhereUniqueInput>
    delete?: Enumerable<ConversationWhereUniqueInput>
    connect?: Enumerable<ConversationWhereUniqueInput>
    update?: Enumerable<ConversationUpdateWithWhereUniqueWithoutFromInput>
    updateMany?: Enumerable<ConversationUpdateManyWithWhereWithoutFromInput>
    deleteMany?: Enumerable<ConversationScalarWhereInput>
  }

  export type ConversationUpdateManyWithoutToNestedInput = {
    create?: XOR<Enumerable<ConversationCreateWithoutToInput>, Enumerable<ConversationUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<ConversationCreateOrConnectWithoutToInput>
    upsert?: Enumerable<ConversationUpsertWithWhereUniqueWithoutToInput>
    createMany?: ConversationCreateManyToInputEnvelope
    set?: Enumerable<ConversationWhereUniqueInput>
    disconnect?: Enumerable<ConversationWhereUniqueInput>
    delete?: Enumerable<ConversationWhereUniqueInput>
    connect?: Enumerable<ConversationWhereUniqueInput>
    update?: Enumerable<ConversationUpdateWithWhereUniqueWithoutToInput>
    updateMany?: Enumerable<ConversationUpdateManyWithWhereWithoutToInput>
    deleteMany?: Enumerable<ConversationScalarWhereInput>
  }

  export type ConversationMessageUpdateManyWithoutFromNestedInput = {
    create?: XOR<Enumerable<ConversationMessageCreateWithoutFromInput>, Enumerable<ConversationMessageUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<ConversationMessageCreateOrConnectWithoutFromInput>
    upsert?: Enumerable<ConversationMessageUpsertWithWhereUniqueWithoutFromInput>
    createMany?: ConversationMessageCreateManyFromInputEnvelope
    set?: Enumerable<ConversationMessageWhereUniqueInput>
    disconnect?: Enumerable<ConversationMessageWhereUniqueInput>
    delete?: Enumerable<ConversationMessageWhereUniqueInput>
    connect?: Enumerable<ConversationMessageWhereUniqueInput>
    update?: Enumerable<ConversationMessageUpdateWithWhereUniqueWithoutFromInput>
    updateMany?: Enumerable<ConversationMessageUpdateManyWithWhereWithoutFromInput>
    deleteMany?: Enumerable<ConversationMessageScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PostUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<PostCreateWithoutUserInput>, Enumerable<PostUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PostCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PostUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PostCreateManyUserInputEnvelope
    set?: Enumerable<PostWhereUniqueInput>
    disconnect?: Enumerable<PostWhereUniqueInput>
    delete?: Enumerable<PostWhereUniqueInput>
    connect?: Enumerable<PostWhereUniqueInput>
    update?: Enumerable<PostUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PostUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PostScalarWhereInput>
  }

  export type PostLikeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<PostLikeCreateWithoutUserInput>, Enumerable<PostLikeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PostLikeCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PostLikeUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PostLikeCreateManyUserInputEnvelope
    set?: Enumerable<PostLikeWhereUniqueInput>
    disconnect?: Enumerable<PostLikeWhereUniqueInput>
    delete?: Enumerable<PostLikeWhereUniqueInput>
    connect?: Enumerable<PostLikeWhereUniqueInput>
    update?: Enumerable<PostLikeUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PostLikeUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PostLikeScalarWhereInput>
  }

  export type PostCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<PostCommentCreateWithoutUserInput>, Enumerable<PostCommentUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<PostCommentCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<PostCommentUpsertWithWhereUniqueWithoutUserInput>
    createMany?: PostCommentCreateManyUserInputEnvelope
    set?: Enumerable<PostCommentWhereUniqueInput>
    disconnect?: Enumerable<PostCommentWhereUniqueInput>
    delete?: Enumerable<PostCommentWhereUniqueInput>
    connect?: Enumerable<PostCommentWhereUniqueInput>
    update?: Enumerable<PostCommentUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<PostCommentUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<PostCommentScalarWhereInput>
  }

  export type FriendshipUncheckedUpdateManyWithoutFromNestedInput = {
    create?: XOR<Enumerable<FriendshipCreateWithoutFromInput>, Enumerable<FriendshipUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<FriendshipCreateOrConnectWithoutFromInput>
    upsert?: Enumerable<FriendshipUpsertWithWhereUniqueWithoutFromInput>
    createMany?: FriendshipCreateManyFromInputEnvelope
    set?: Enumerable<FriendshipWhereUniqueInput>
    disconnect?: Enumerable<FriendshipWhereUniqueInput>
    delete?: Enumerable<FriendshipWhereUniqueInput>
    connect?: Enumerable<FriendshipWhereUniqueInput>
    update?: Enumerable<FriendshipUpdateWithWhereUniqueWithoutFromInput>
    updateMany?: Enumerable<FriendshipUpdateManyWithWhereWithoutFromInput>
    deleteMany?: Enumerable<FriendshipScalarWhereInput>
  }

  export type FriendshipUncheckedUpdateManyWithoutToNestedInput = {
    create?: XOR<Enumerable<FriendshipCreateWithoutToInput>, Enumerable<FriendshipUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<FriendshipCreateOrConnectWithoutToInput>
    upsert?: Enumerable<FriendshipUpsertWithWhereUniqueWithoutToInput>
    createMany?: FriendshipCreateManyToInputEnvelope
    set?: Enumerable<FriendshipWhereUniqueInput>
    disconnect?: Enumerable<FriendshipWhereUniqueInput>
    delete?: Enumerable<FriendshipWhereUniqueInput>
    connect?: Enumerable<FriendshipWhereUniqueInput>
    update?: Enumerable<FriendshipUpdateWithWhereUniqueWithoutToInput>
    updateMany?: Enumerable<FriendshipUpdateManyWithWhereWithoutToInput>
    deleteMany?: Enumerable<FriendshipScalarWhereInput>
  }

  export type UserUncheckedUpdateManyWithoutBlockedByUsersNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutBlockedByUsersInput>, Enumerable<UserUncheckedCreateWithoutBlockedByUsersInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutBlockedByUsersInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutBlockedByUsersInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutBlockedByUsersInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutBlockedByUsersInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type UserUncheckedUpdateManyWithoutBlockedUsersNestedInput = {
    create?: XOR<Enumerable<UserCreateWithoutBlockedUsersInput>, Enumerable<UserUncheckedCreateWithoutBlockedUsersInput>>
    connectOrCreate?: Enumerable<UserCreateOrConnectWithoutBlockedUsersInput>
    upsert?: Enumerable<UserUpsertWithWhereUniqueWithoutBlockedUsersInput>
    set?: Enumerable<UserWhereUniqueInput>
    disconnect?: Enumerable<UserWhereUniqueInput>
    delete?: Enumerable<UserWhereUniqueInput>
    connect?: Enumerable<UserWhereUniqueInput>
    update?: Enumerable<UserUpdateWithWhereUniqueWithoutBlockedUsersInput>
    updateMany?: Enumerable<UserUpdateManyWithWhereWithoutBlockedUsersInput>
    deleteMany?: Enumerable<UserScalarWhereInput>
  }

  export type ConversationUncheckedUpdateManyWithoutFromNestedInput = {
    create?: XOR<Enumerable<ConversationCreateWithoutFromInput>, Enumerable<ConversationUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<ConversationCreateOrConnectWithoutFromInput>
    upsert?: Enumerable<ConversationUpsertWithWhereUniqueWithoutFromInput>
    createMany?: ConversationCreateManyFromInputEnvelope
    set?: Enumerable<ConversationWhereUniqueInput>
    disconnect?: Enumerable<ConversationWhereUniqueInput>
    delete?: Enumerable<ConversationWhereUniqueInput>
    connect?: Enumerable<ConversationWhereUniqueInput>
    update?: Enumerable<ConversationUpdateWithWhereUniqueWithoutFromInput>
    updateMany?: Enumerable<ConversationUpdateManyWithWhereWithoutFromInput>
    deleteMany?: Enumerable<ConversationScalarWhereInput>
  }

  export type ConversationUncheckedUpdateManyWithoutToNestedInput = {
    create?: XOR<Enumerable<ConversationCreateWithoutToInput>, Enumerable<ConversationUncheckedCreateWithoutToInput>>
    connectOrCreate?: Enumerable<ConversationCreateOrConnectWithoutToInput>
    upsert?: Enumerable<ConversationUpsertWithWhereUniqueWithoutToInput>
    createMany?: ConversationCreateManyToInputEnvelope
    set?: Enumerable<ConversationWhereUniqueInput>
    disconnect?: Enumerable<ConversationWhereUniqueInput>
    delete?: Enumerable<ConversationWhereUniqueInput>
    connect?: Enumerable<ConversationWhereUniqueInput>
    update?: Enumerable<ConversationUpdateWithWhereUniqueWithoutToInput>
    updateMany?: Enumerable<ConversationUpdateManyWithWhereWithoutToInput>
    deleteMany?: Enumerable<ConversationScalarWhereInput>
  }

  export type ConversationMessageUncheckedUpdateManyWithoutFromNestedInput = {
    create?: XOR<Enumerable<ConversationMessageCreateWithoutFromInput>, Enumerable<ConversationMessageUncheckedCreateWithoutFromInput>>
    connectOrCreate?: Enumerable<ConversationMessageCreateOrConnectWithoutFromInput>
    upsert?: Enumerable<ConversationMessageUpsertWithWhereUniqueWithoutFromInput>
    createMany?: ConversationMessageCreateManyFromInputEnvelope
    set?: Enumerable<ConversationMessageWhereUniqueInput>
    disconnect?: Enumerable<ConversationMessageWhereUniqueInput>
    delete?: Enumerable<ConversationMessageWhereUniqueInput>
    connect?: Enumerable<ConversationMessageWhereUniqueInput>
    update?: Enumerable<ConversationMessageUpdateWithWhereUniqueWithoutFromInput>
    updateMany?: Enumerable<ConversationMessageUpdateManyWithWhereWithoutFromInput>
    deleteMany?: Enumerable<ConversationMessageScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutPostsInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    connect?: UserWhereUniqueInput
  }

  export type PostLikeCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<PostLikeCreateWithoutPostInput>, Enumerable<PostLikeUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<PostLikeCreateOrConnectWithoutPostInput>
    createMany?: PostLikeCreateManyPostInputEnvelope
    connect?: Enumerable<PostLikeWhereUniqueInput>
  }

  export type PostCommentCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<PostCommentCreateWithoutPostInput>, Enumerable<PostCommentUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<PostCommentCreateOrConnectWithoutPostInput>
    createMany?: PostCommentCreateManyPostInputEnvelope
    connect?: Enumerable<PostCommentWhereUniqueInput>
  }

  export type PostLikeUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<PostLikeCreateWithoutPostInput>, Enumerable<PostLikeUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<PostLikeCreateOrConnectWithoutPostInput>
    createMany?: PostLikeCreateManyPostInputEnvelope
    connect?: Enumerable<PostLikeWhereUniqueInput>
  }

  export type PostCommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<Enumerable<PostCommentCreateWithoutPostInput>, Enumerable<PostCommentUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<PostCommentCreateOrConnectWithoutPostInput>
    createMany?: PostCommentCreateManyPostInputEnvelope
    connect?: Enumerable<PostCommentWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    upsert?: UserUpsertWithoutPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
  }

  export type PostLikeUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<PostLikeCreateWithoutPostInput>, Enumerable<PostLikeUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<PostLikeCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<PostLikeUpsertWithWhereUniqueWithoutPostInput>
    createMany?: PostLikeCreateManyPostInputEnvelope
    set?: Enumerable<PostLikeWhereUniqueInput>
    disconnect?: Enumerable<PostLikeWhereUniqueInput>
    delete?: Enumerable<PostLikeWhereUniqueInput>
    connect?: Enumerable<PostLikeWhereUniqueInput>
    update?: Enumerable<PostLikeUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<PostLikeUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<PostLikeScalarWhereInput>
  }

  export type PostCommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<PostCommentCreateWithoutPostInput>, Enumerable<PostCommentUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<PostCommentCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<PostCommentUpsertWithWhereUniqueWithoutPostInput>
    createMany?: PostCommentCreateManyPostInputEnvelope
    set?: Enumerable<PostCommentWhereUniqueInput>
    disconnect?: Enumerable<PostCommentWhereUniqueInput>
    delete?: Enumerable<PostCommentWhereUniqueInput>
    connect?: Enumerable<PostCommentWhereUniqueInput>
    update?: Enumerable<PostCommentUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<PostCommentUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<PostCommentScalarWhereInput>
  }

  export type PostLikeUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<PostLikeCreateWithoutPostInput>, Enumerable<PostLikeUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<PostLikeCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<PostLikeUpsertWithWhereUniqueWithoutPostInput>
    createMany?: PostLikeCreateManyPostInputEnvelope
    set?: Enumerable<PostLikeWhereUniqueInput>
    disconnect?: Enumerable<PostLikeWhereUniqueInput>
    delete?: Enumerable<PostLikeWhereUniqueInput>
    connect?: Enumerable<PostLikeWhereUniqueInput>
    update?: Enumerable<PostLikeUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<PostLikeUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<PostLikeScalarWhereInput>
  }

  export type PostCommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<Enumerable<PostCommentCreateWithoutPostInput>, Enumerable<PostCommentUncheckedCreateWithoutPostInput>>
    connectOrCreate?: Enumerable<PostCommentCreateOrConnectWithoutPostInput>
    upsert?: Enumerable<PostCommentUpsertWithWhereUniqueWithoutPostInput>
    createMany?: PostCommentCreateManyPostInputEnvelope
    set?: Enumerable<PostCommentWhereUniqueInput>
    disconnect?: Enumerable<PostCommentWhereUniqueInput>
    delete?: Enumerable<PostCommentWhereUniqueInput>
    connect?: Enumerable<PostCommentWhereUniqueInput>
    update?: Enumerable<PostCommentUpdateWithWhereUniqueWithoutPostInput>
    updateMany?: Enumerable<PostCommentUpdateManyWithWhereWithoutPostInput>
    deleteMany?: Enumerable<PostCommentScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutPostLikesInput = {
    create?: XOR<UserCreateWithoutPostLikesInput, UserUncheckedCreateWithoutPostLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostLikesInput
    connect?: UserWhereUniqueInput
  }

  export type PostCreateNestedOneWithoutPostLikesInput = {
    create?: XOR<PostCreateWithoutPostLikesInput, PostUncheckedCreateWithoutPostLikesInput>
    connectOrCreate?: PostCreateOrConnectWithoutPostLikesInput
    connect?: PostWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPostLikesNestedInput = {
    create?: XOR<UserCreateWithoutPostLikesInput, UserUncheckedCreateWithoutPostLikesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostLikesInput
    upsert?: UserUpsertWithoutPostLikesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutPostLikesInput, UserUncheckedUpdateWithoutPostLikesInput>
  }

  export type PostUpdateOneRequiredWithoutPostLikesNestedInput = {
    create?: XOR<PostCreateWithoutPostLikesInput, PostUncheckedCreateWithoutPostLikesInput>
    connectOrCreate?: PostCreateOrConnectWithoutPostLikesInput
    upsert?: PostUpsertWithoutPostLikesInput
    connect?: PostWhereUniqueInput
    update?: XOR<PostUpdateWithoutPostLikesInput, PostUncheckedUpdateWithoutPostLikesInput>
  }

  export type UserCreateNestedOneWithoutPostCommentInput = {
    create?: XOR<UserCreateWithoutPostCommentInput, UserUncheckedCreateWithoutPostCommentInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostCommentInput
    connect?: UserWhereUniqueInput
  }

  export type PostCreateNestedOneWithoutPostCommentsInput = {
    create?: XOR<PostCreateWithoutPostCommentsInput, PostUncheckedCreateWithoutPostCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutPostCommentsInput
    connect?: PostWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPostCommentNestedInput = {
    create?: XOR<UserCreateWithoutPostCommentInput, UserUncheckedCreateWithoutPostCommentInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostCommentInput
    upsert?: UserUpsertWithoutPostCommentInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutPostCommentInput, UserUncheckedUpdateWithoutPostCommentInput>
  }

  export type PostUpdateOneRequiredWithoutPostCommentsNestedInput = {
    create?: XOR<PostCreateWithoutPostCommentsInput, PostUncheckedCreateWithoutPostCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutPostCommentsInput
    upsert?: PostUpsertWithoutPostCommentsInput
    connect?: PostWhereUniqueInput
    update?: XOR<PostUpdateWithoutPostCommentsInput, PostUncheckedUpdateWithoutPostCommentsInput>
  }

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: DocumentType
  }

  export type UserCreateNestedOneWithoutFromFriendshipInput = {
    create?: XOR<UserCreateWithoutFromFriendshipInput, UserUncheckedCreateWithoutFromFriendshipInput>
    connectOrCreate?: UserCreateOrConnectWithoutFromFriendshipInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutToFrienshipInput = {
    create?: XOR<UserCreateWithoutToFrienshipInput, UserUncheckedCreateWithoutToFrienshipInput>
    connectOrCreate?: UserCreateOrConnectWithoutToFrienshipInput
    connect?: UserWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutFriendshipInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutFriendshipInput>, Enumerable<NotificationUncheckedCreateWithoutFriendshipInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutFriendshipInput>
    createMany?: NotificationCreateManyFriendshipInputEnvelope
    connect?: Enumerable<NotificationWhereUniqueInput>
  }

  export type NotificationUncheckedCreateNestedManyWithoutFriendshipInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutFriendshipInput>, Enumerable<NotificationUncheckedCreateWithoutFriendshipInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutFriendshipInput>
    createMany?: NotificationCreateManyFriendshipInputEnvelope
    connect?: Enumerable<NotificationWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutFromFriendshipNestedInput = {
    create?: XOR<UserCreateWithoutFromFriendshipInput, UserUncheckedCreateWithoutFromFriendshipInput>
    connectOrCreate?: UserCreateOrConnectWithoutFromFriendshipInput
    upsert?: UserUpsertWithoutFromFriendshipInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutFromFriendshipInput, UserUncheckedUpdateWithoutFromFriendshipInput>
  }

  export type UserUpdateOneRequiredWithoutToFrienshipNestedInput = {
    create?: XOR<UserCreateWithoutToFrienshipInput, UserUncheckedCreateWithoutToFrienshipInput>
    connectOrCreate?: UserCreateOrConnectWithoutToFrienshipInput
    upsert?: UserUpsertWithoutToFrienshipInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutToFrienshipInput, UserUncheckedUpdateWithoutToFrienshipInput>
  }

  export type EnumFriendshipStatusFieldUpdateOperationsInput = {
    set?: FriendshipStatus
  }

  export type NotificationUpdateManyWithoutFriendshipNestedInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutFriendshipInput>, Enumerable<NotificationUncheckedCreateWithoutFriendshipInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutFriendshipInput>
    upsert?: Enumerable<NotificationUpsertWithWhereUniqueWithoutFriendshipInput>
    createMany?: NotificationCreateManyFriendshipInputEnvelope
    set?: Enumerable<NotificationWhereUniqueInput>
    disconnect?: Enumerable<NotificationWhereUniqueInput>
    delete?: Enumerable<NotificationWhereUniqueInput>
    connect?: Enumerable<NotificationWhereUniqueInput>
    update?: Enumerable<NotificationUpdateWithWhereUniqueWithoutFriendshipInput>
    updateMany?: Enumerable<NotificationUpdateManyWithWhereWithoutFriendshipInput>
    deleteMany?: Enumerable<NotificationScalarWhereInput>
  }

  export type NotificationUncheckedUpdateManyWithoutFriendshipNestedInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutFriendshipInput>, Enumerable<NotificationUncheckedCreateWithoutFriendshipInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutFriendshipInput>
    upsert?: Enumerable<NotificationUpsertWithWhereUniqueWithoutFriendshipInput>
    createMany?: NotificationCreateManyFriendshipInputEnvelope
    set?: Enumerable<NotificationWhereUniqueInput>
    disconnect?: Enumerable<NotificationWhereUniqueInput>
    delete?: Enumerable<NotificationWhereUniqueInput>
    connect?: Enumerable<NotificationWhereUniqueInput>
    update?: Enumerable<NotificationUpdateWithWhereUniqueWithoutFriendshipInput>
    updateMany?: Enumerable<NotificationUpdateManyWithWhereWithoutFriendshipInput>
    deleteMany?: Enumerable<NotificationScalarWhereInput>
  }

  export type UserCreateNestedOneWithoutConversationsSentInput = {
    create?: XOR<UserCreateWithoutConversationsSentInput, UserUncheckedCreateWithoutConversationsSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsSentInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutConversationsReceivedInput = {
    create?: XOR<UserCreateWithoutConversationsReceivedInput, UserUncheckedCreateWithoutConversationsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type ConversationMessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<Enumerable<ConversationMessageCreateWithoutConversationInput>, Enumerable<ConversationMessageUncheckedCreateWithoutConversationInput>>
    connectOrCreate?: Enumerable<ConversationMessageCreateOrConnectWithoutConversationInput>
    createMany?: ConversationMessageCreateManyConversationInputEnvelope
    connect?: Enumerable<ConversationMessageWhereUniqueInput>
  }

  export type ConversationMessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<Enumerable<ConversationMessageCreateWithoutConversationInput>, Enumerable<ConversationMessageUncheckedCreateWithoutConversationInput>>
    connectOrCreate?: Enumerable<ConversationMessageCreateOrConnectWithoutConversationInput>
    createMany?: ConversationMessageCreateManyConversationInputEnvelope
    connect?: Enumerable<ConversationMessageWhereUniqueInput>
  }

  export type UserUpdateOneRequiredWithoutConversationsSentNestedInput = {
    create?: XOR<UserCreateWithoutConversationsSentInput, UserUncheckedCreateWithoutConversationsSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsSentInput
    upsert?: UserUpsertWithoutConversationsSentInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutConversationsSentInput, UserUncheckedUpdateWithoutConversationsSentInput>
  }

  export type UserUpdateOneWithoutConversationsReceivedNestedInput = {
    create?: XOR<UserCreateWithoutConversationsReceivedInput, UserUncheckedCreateWithoutConversationsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsReceivedInput
    upsert?: UserUpsertWithoutConversationsReceivedInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutConversationsReceivedInput, UserUncheckedUpdateWithoutConversationsReceivedInput>
  }

  export type ConversationMessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<Enumerable<ConversationMessageCreateWithoutConversationInput>, Enumerable<ConversationMessageUncheckedCreateWithoutConversationInput>>
    connectOrCreate?: Enumerable<ConversationMessageCreateOrConnectWithoutConversationInput>
    upsert?: Enumerable<ConversationMessageUpsertWithWhereUniqueWithoutConversationInput>
    createMany?: ConversationMessageCreateManyConversationInputEnvelope
    set?: Enumerable<ConversationMessageWhereUniqueInput>
    disconnect?: Enumerable<ConversationMessageWhereUniqueInput>
    delete?: Enumerable<ConversationMessageWhereUniqueInput>
    connect?: Enumerable<ConversationMessageWhereUniqueInput>
    update?: Enumerable<ConversationMessageUpdateWithWhereUniqueWithoutConversationInput>
    updateMany?: Enumerable<ConversationMessageUpdateManyWithWhereWithoutConversationInput>
    deleteMany?: Enumerable<ConversationMessageScalarWhereInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ConversationMessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<Enumerable<ConversationMessageCreateWithoutConversationInput>, Enumerable<ConversationMessageUncheckedCreateWithoutConversationInput>>
    connectOrCreate?: Enumerable<ConversationMessageCreateOrConnectWithoutConversationInput>
    upsert?: Enumerable<ConversationMessageUpsertWithWhereUniqueWithoutConversationInput>
    createMany?: ConversationMessageCreateManyConversationInputEnvelope
    set?: Enumerable<ConversationMessageWhereUniqueInput>
    disconnect?: Enumerable<ConversationMessageWhereUniqueInput>
    delete?: Enumerable<ConversationMessageWhereUniqueInput>
    connect?: Enumerable<ConversationMessageWhereUniqueInput>
    update?: Enumerable<ConversationMessageUpdateWithWhereUniqueWithoutConversationInput>
    updateMany?: Enumerable<ConversationMessageUpdateManyWithWhereWithoutConversationInput>
    deleteMany?: Enumerable<ConversationMessageScalarWhereInput>
  }

  export type ConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutConversationMessagesInput = {
    create?: XOR<UserCreateWithoutConversationMessagesInput, UserUncheckedCreateWithoutConversationMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutMessageInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutMessageInput>, Enumerable<NotificationUncheckedCreateWithoutMessageInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutMessageInput>
    createMany?: NotificationCreateManyMessageInputEnvelope
    connect?: Enumerable<NotificationWhereUniqueInput>
  }

  export type NotificationUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutMessageInput>, Enumerable<NotificationUncheckedCreateWithoutMessageInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutMessageInput>
    createMany?: NotificationCreateManyMessageInputEnvelope
    connect?: Enumerable<NotificationWhereUniqueInput>
  }

  export type ConversationUpdateOneWithoutMessagesNestedInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    upsert?: ConversationUpsertWithoutMessagesInput
    disconnect?: boolean
    delete?: boolean
    connect?: ConversationWhereUniqueInput
    update?: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutConversationMessagesNestedInput = {
    create?: XOR<UserCreateWithoutConversationMessagesInput, UserUncheckedCreateWithoutConversationMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationMessagesInput
    upsert?: UserUpsertWithoutConversationMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutConversationMessagesInput, UserUncheckedUpdateWithoutConversationMessagesInput>
  }

  export type NotificationUpdateManyWithoutMessageNestedInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutMessageInput>, Enumerable<NotificationUncheckedCreateWithoutMessageInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutMessageInput>
    upsert?: Enumerable<NotificationUpsertWithWhereUniqueWithoutMessageInput>
    createMany?: NotificationCreateManyMessageInputEnvelope
    set?: Enumerable<NotificationWhereUniqueInput>
    disconnect?: Enumerable<NotificationWhereUniqueInput>
    delete?: Enumerable<NotificationWhereUniqueInput>
    connect?: Enumerable<NotificationWhereUniqueInput>
    update?: Enumerable<NotificationUpdateWithWhereUniqueWithoutMessageInput>
    updateMany?: Enumerable<NotificationUpdateManyWithWhereWithoutMessageInput>
    deleteMany?: Enumerable<NotificationScalarWhereInput>
  }

  export type NotificationUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<Enumerable<NotificationCreateWithoutMessageInput>, Enumerable<NotificationUncheckedCreateWithoutMessageInput>>
    connectOrCreate?: Enumerable<NotificationCreateOrConnectWithoutMessageInput>
    upsert?: Enumerable<NotificationUpsertWithWhereUniqueWithoutMessageInput>
    createMany?: NotificationCreateManyMessageInputEnvelope
    set?: Enumerable<NotificationWhereUniqueInput>
    disconnect?: Enumerable<NotificationWhereUniqueInput>
    delete?: Enumerable<NotificationWhereUniqueInput>
    connect?: Enumerable<NotificationWhereUniqueInput>
    update?: Enumerable<NotificationUpdateWithWhereUniqueWithoutMessageInput>
    updateMany?: Enumerable<NotificationUpdateManyWithWhereWithoutMessageInput>
    deleteMany?: Enumerable<NotificationScalarWhereInput>
  }

  export type FriendshipCreateNestedOneWithoutNotificationInput = {
    create?: XOR<FriendshipCreateWithoutNotificationInput, FriendshipUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: FriendshipCreateOrConnectWithoutNotificationInput
    connect?: FriendshipWhereUniqueInput
  }

  export type ConversationMessageCreateNestedOneWithoutNotificationInput = {
    create?: XOR<ConversationMessageCreateWithoutNotificationInput, ConversationMessageUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: ConversationMessageCreateOrConnectWithoutNotificationInput
    connect?: ConversationMessageWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type FriendshipUpdateOneWithoutNotificationNestedInput = {
    create?: XOR<FriendshipCreateWithoutNotificationInput, FriendshipUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: FriendshipCreateOrConnectWithoutNotificationInput
    upsert?: FriendshipUpsertWithoutNotificationInput
    disconnect?: boolean
    delete?: boolean
    connect?: FriendshipWhereUniqueInput
    update?: XOR<FriendshipUpdateWithoutNotificationInput, FriendshipUncheckedUpdateWithoutNotificationInput>
  }

  export type ConversationMessageUpdateOneWithoutNotificationNestedInput = {
    create?: XOR<ConversationMessageCreateWithoutNotificationInput, ConversationMessageUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: ConversationMessageCreateOrConnectWithoutNotificationInput
    upsert?: ConversationMessageUpsertWithoutNotificationInput
    disconnect?: boolean
    delete?: boolean
    connect?: ConversationMessageWhereUniqueInput
    update?: XOR<ConversationMessageUpdateWithoutNotificationInput, ConversationMessageUncheckedUpdateWithoutNotificationInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedEnumDocumentTypeFilter = {
    equals?: DocumentType
    in?: Enumerable<DocumentType>
    notIn?: Enumerable<DocumentType>
    not?: NestedEnumDocumentTypeFilter | DocumentType
  }

  export type NestedEnumDocumentTypeWithAggregatesFilter = {
    equals?: DocumentType
    in?: Enumerable<DocumentType>
    notIn?: Enumerable<DocumentType>
    not?: NestedEnumDocumentTypeWithAggregatesFilter | DocumentType
    _count?: NestedIntFilter
    _min?: NestedEnumDocumentTypeFilter
    _max?: NestedEnumDocumentTypeFilter
  }

  export type NestedEnumFriendshipStatusFilter = {
    equals?: FriendshipStatus
    in?: Enumerable<FriendshipStatus>
    notIn?: Enumerable<FriendshipStatus>
    not?: NestedEnumFriendshipStatusFilter | FriendshipStatus
  }

  export type NestedEnumFriendshipStatusWithAggregatesFilter = {
    equals?: FriendshipStatus
    in?: Enumerable<FriendshipStatus>
    notIn?: Enumerable<FriendshipStatus>
    not?: NestedEnumFriendshipStatusWithAggregatesFilter | FriendshipStatus
    _count?: NestedIntFilter
    _min?: NestedEnumFriendshipStatusFilter
    _max?: NestedEnumFriendshipStatusFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type PostCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    htmlContent: string
    PostLikes?: PostLikeCreateNestedManyWithoutPostInput
    PostComments?: PostCommentCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    htmlContent: string
    PostLikes?: PostLikeUncheckedCreateNestedManyWithoutPostInput
    PostComments?: PostCommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutUserInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput>
  }

  export type PostCreateManyUserInputEnvelope = {
    data: Enumerable<PostCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type PostLikeCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    Post: PostCreateNestedOneWithoutPostLikesInput
  }

  export type PostLikeUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    postId: number
  }

  export type PostLikeCreateOrConnectWithoutUserInput = {
    where: PostLikeWhereUniqueInput
    create: XOR<PostLikeCreateWithoutUserInput, PostLikeUncheckedCreateWithoutUserInput>
  }

  export type PostLikeCreateManyUserInputEnvelope = {
    data: Enumerable<PostLikeCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type PostCommentCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    Post: PostCreateNestedOneWithoutPostCommentsInput
    text: string
  }

  export type PostCommentUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    postId: number
    text: string
  }

  export type PostCommentCreateOrConnectWithoutUserInput = {
    where: PostCommentWhereUniqueInput
    create: XOR<PostCommentCreateWithoutUserInput, PostCommentUncheckedCreateWithoutUserInput>
  }

  export type PostCommentCreateManyUserInputEnvelope = {
    data: Enumerable<PostCommentCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type FriendshipCreateWithoutFromInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    to: UserCreateNestedOneWithoutToFrienshipInput
    status?: FriendshipStatus
    Notification?: NotificationCreateNestedManyWithoutFriendshipInput
  }

  export type FriendshipUncheckedCreateWithoutFromInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: FriendshipStatus
    toId: number
    Notification?: NotificationUncheckedCreateNestedManyWithoutFriendshipInput
  }

  export type FriendshipCreateOrConnectWithoutFromInput = {
    where: FriendshipWhereUniqueInput
    create: XOR<FriendshipCreateWithoutFromInput, FriendshipUncheckedCreateWithoutFromInput>
  }

  export type FriendshipCreateManyFromInputEnvelope = {
    data: Enumerable<FriendshipCreateManyFromInput>
    skipDuplicates?: boolean
  }

  export type FriendshipCreateWithoutToInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    from: UserCreateNestedOneWithoutFromFriendshipInput
    status?: FriendshipStatus
    Notification?: NotificationCreateNestedManyWithoutFriendshipInput
  }

  export type FriendshipUncheckedCreateWithoutToInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: FriendshipStatus
    fromId: number
    Notification?: NotificationUncheckedCreateNestedManyWithoutFriendshipInput
  }

  export type FriendshipCreateOrConnectWithoutToInput = {
    where: FriendshipWhereUniqueInput
    create: XOR<FriendshipCreateWithoutToInput, FriendshipUncheckedCreateWithoutToInput>
  }

  export type FriendshipCreateManyToInputEnvelope = {
    data: Enumerable<FriendshipCreateManyToInput>
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutBlockedByUsersInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    firstname: string
    lastname: string
    email: string
    avatarS3Key: string
    coverPicS3Key: string
    Posts?: PostCreateNestedManyWithoutUserInput
    PostLikes?: PostLikeCreateNestedManyWithoutUserInput
    PostComment?: PostCommentCreateNestedManyWithoutUserInput
    FromFriendship?: FriendshipCreateNestedManyWithoutFromInput
    ToFrienship?: FriendshipCreateNestedManyWithoutToInput
    BlockedUsers?: UserCreateNestedManyWithoutBlockedByUsersInput
    ConversationsSent?: ConversationCreateNestedManyWithoutFromInput
    ConversationsReceived?: ConversationCreateNestedManyWithoutToInput
    ConversationMessages?: ConversationMessageCreateNestedManyWithoutFromInput
  }

  export type UserUncheckedCreateWithoutBlockedByUsersInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    firstname: string
    lastname: string
    email: string
    avatarS3Key: string
    coverPicS3Key: string
    Posts?: PostUncheckedCreateNestedManyWithoutUserInput
    PostLikes?: PostLikeUncheckedCreateNestedManyWithoutUserInput
    PostComment?: PostCommentUncheckedCreateNestedManyWithoutUserInput
    FromFriendship?: FriendshipUncheckedCreateNestedManyWithoutFromInput
    ToFrienship?: FriendshipUncheckedCreateNestedManyWithoutToInput
    BlockedUsers?: UserUncheckedCreateNestedManyWithoutBlockedByUsersInput
    ConversationsSent?: ConversationUncheckedCreateNestedManyWithoutFromInput
    ConversationsReceived?: ConversationUncheckedCreateNestedManyWithoutToInput
    ConversationMessages?: ConversationMessageUncheckedCreateNestedManyWithoutFromInput
  }

  export type UserCreateOrConnectWithoutBlockedByUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlockedByUsersInput, UserUncheckedCreateWithoutBlockedByUsersInput>
  }

  export type UserCreateWithoutBlockedUsersInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    firstname: string
    lastname: string
    email: string
    avatarS3Key: string
    coverPicS3Key: string
    Posts?: PostCreateNestedManyWithoutUserInput
    PostLikes?: PostLikeCreateNestedManyWithoutUserInput
    PostComment?: PostCommentCreateNestedManyWithoutUserInput
    FromFriendship?: FriendshipCreateNestedManyWithoutFromInput
    ToFrienship?: FriendshipCreateNestedManyWithoutToInput
    BlockedByUsers?: UserCreateNestedManyWithoutBlockedUsersInput
    ConversationsSent?: ConversationCreateNestedManyWithoutFromInput
    ConversationsReceived?: ConversationCreateNestedManyWithoutToInput
    ConversationMessages?: ConversationMessageCreateNestedManyWithoutFromInput
  }

  export type UserUncheckedCreateWithoutBlockedUsersInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    firstname: string
    lastname: string
    email: string
    avatarS3Key: string
    coverPicS3Key: string
    Posts?: PostUncheckedCreateNestedManyWithoutUserInput
    PostLikes?: PostLikeUncheckedCreateNestedManyWithoutUserInput
    PostComment?: PostCommentUncheckedCreateNestedManyWithoutUserInput
    FromFriendship?: FriendshipUncheckedCreateNestedManyWithoutFromInput
    ToFrienship?: FriendshipUncheckedCreateNestedManyWithoutToInput
    BlockedByUsers?: UserUncheckedCreateNestedManyWithoutBlockedUsersInput
    ConversationsSent?: ConversationUncheckedCreateNestedManyWithoutFromInput
    ConversationsReceived?: ConversationUncheckedCreateNestedManyWithoutToInput
    ConversationMessages?: ConversationMessageUncheckedCreateNestedManyWithoutFromInput
  }

  export type UserCreateOrConnectWithoutBlockedUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlockedUsersInput, UserUncheckedCreateWithoutBlockedUsersInput>
  }

  export type ConversationCreateWithoutFromInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    To?: UserCreateNestedOneWithoutConversationsReceivedInput
    Messages?: ConversationMessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutFromInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    toId?: number | null
    Messages?: ConversationMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutFromInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutFromInput, ConversationUncheckedCreateWithoutFromInput>
  }

  export type ConversationCreateManyFromInputEnvelope = {
    data: Enumerable<ConversationCreateManyFromInput>
    skipDuplicates?: boolean
  }

  export type ConversationCreateWithoutToInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    From: UserCreateNestedOneWithoutConversationsSentInput
    Messages?: ConversationMessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutToInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    fromId: number
    Messages?: ConversationMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutToInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutToInput, ConversationUncheckedCreateWithoutToInput>
  }

  export type ConversationCreateManyToInputEnvelope = {
    data: Enumerable<ConversationCreateManyToInput>
    skipDuplicates?: boolean
  }

  export type ConversationMessageCreateWithoutFromInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    Conversation?: ConversationCreateNestedOneWithoutMessagesInput
    Notification?: NotificationCreateNestedManyWithoutMessageInput
  }

  export type ConversationMessageUncheckedCreateWithoutFromInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    conversationId?: number | null
    Notification?: NotificationUncheckedCreateNestedManyWithoutMessageInput
  }

  export type ConversationMessageCreateOrConnectWithoutFromInput = {
    where: ConversationMessageWhereUniqueInput
    create: XOR<ConversationMessageCreateWithoutFromInput, ConversationMessageUncheckedCreateWithoutFromInput>
  }

  export type ConversationMessageCreateManyFromInputEnvelope = {
    data: Enumerable<ConversationMessageCreateManyFromInput>
    skipDuplicates?: boolean
  }

  export type PostUpsertWithWhereUniqueWithoutUserInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutUserInput, PostUncheckedUpdateWithoutUserInput>
    create: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput>
  }

  export type PostUpdateWithWhereUniqueWithoutUserInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutUserInput, PostUncheckedUpdateWithoutUserInput>
  }

  export type PostUpdateManyWithWhereWithoutUserInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutPostsInput>
  }

  export type PostScalarWhereInput = {
    AND?: Enumerable<PostScalarWhereInput>
    OR?: Enumerable<PostScalarWhereInput>
    NOT?: Enumerable<PostScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    htmlContent?: StringFilter | string
    userId?: IntFilter | number
  }

  export type PostLikeUpsertWithWhereUniqueWithoutUserInput = {
    where: PostLikeWhereUniqueInput
    update: XOR<PostLikeUpdateWithoutUserInput, PostLikeUncheckedUpdateWithoutUserInput>
    create: XOR<PostLikeCreateWithoutUserInput, PostLikeUncheckedCreateWithoutUserInput>
  }

  export type PostLikeUpdateWithWhereUniqueWithoutUserInput = {
    where: PostLikeWhereUniqueInput
    data: XOR<PostLikeUpdateWithoutUserInput, PostLikeUncheckedUpdateWithoutUserInput>
  }

  export type PostLikeUpdateManyWithWhereWithoutUserInput = {
    where: PostLikeScalarWhereInput
    data: XOR<PostLikeUpdateManyMutationInput, PostLikeUncheckedUpdateManyWithoutPostLikesInput>
  }

  export type PostLikeScalarWhereInput = {
    AND?: Enumerable<PostLikeScalarWhereInput>
    OR?: Enumerable<PostLikeScalarWhereInput>
    NOT?: Enumerable<PostLikeScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    userId?: IntFilter | number
    postId?: IntFilter | number
  }

  export type PostCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: PostCommentWhereUniqueInput
    update: XOR<PostCommentUpdateWithoutUserInput, PostCommentUncheckedUpdateWithoutUserInput>
    create: XOR<PostCommentCreateWithoutUserInput, PostCommentUncheckedCreateWithoutUserInput>
  }

  export type PostCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: PostCommentWhereUniqueInput
    data: XOR<PostCommentUpdateWithoutUserInput, PostCommentUncheckedUpdateWithoutUserInput>
  }

  export type PostCommentUpdateManyWithWhereWithoutUserInput = {
    where: PostCommentScalarWhereInput
    data: XOR<PostCommentUpdateManyMutationInput, PostCommentUncheckedUpdateManyWithoutPostCommentInput>
  }

  export type PostCommentScalarWhereInput = {
    AND?: Enumerable<PostCommentScalarWhereInput>
    OR?: Enumerable<PostCommentScalarWhereInput>
    NOT?: Enumerable<PostCommentScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    userId?: IntFilter | number
    postId?: IntFilter | number
    text?: StringFilter | string
  }

  export type FriendshipUpsertWithWhereUniqueWithoutFromInput = {
    where: FriendshipWhereUniqueInput
    update: XOR<FriendshipUpdateWithoutFromInput, FriendshipUncheckedUpdateWithoutFromInput>
    create: XOR<FriendshipCreateWithoutFromInput, FriendshipUncheckedCreateWithoutFromInput>
  }

  export type FriendshipUpdateWithWhereUniqueWithoutFromInput = {
    where: FriendshipWhereUniqueInput
    data: XOR<FriendshipUpdateWithoutFromInput, FriendshipUncheckedUpdateWithoutFromInput>
  }

  export type FriendshipUpdateManyWithWhereWithoutFromInput = {
    where: FriendshipScalarWhereInput
    data: XOR<FriendshipUpdateManyMutationInput, FriendshipUncheckedUpdateManyWithoutFromFriendshipInput>
  }

  export type FriendshipScalarWhereInput = {
    AND?: Enumerable<FriendshipScalarWhereInput>
    OR?: Enumerable<FriendshipScalarWhereInput>
    NOT?: Enumerable<FriendshipScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    status?: EnumFriendshipStatusFilter | FriendshipStatus
    fromId?: IntFilter | number
    toId?: IntFilter | number
  }

  export type FriendshipUpsertWithWhereUniqueWithoutToInput = {
    where: FriendshipWhereUniqueInput
    update: XOR<FriendshipUpdateWithoutToInput, FriendshipUncheckedUpdateWithoutToInput>
    create: XOR<FriendshipCreateWithoutToInput, FriendshipUncheckedCreateWithoutToInput>
  }

  export type FriendshipUpdateWithWhereUniqueWithoutToInput = {
    where: FriendshipWhereUniqueInput
    data: XOR<FriendshipUpdateWithoutToInput, FriendshipUncheckedUpdateWithoutToInput>
  }

  export type FriendshipUpdateManyWithWhereWithoutToInput = {
    where: FriendshipScalarWhereInput
    data: XOR<FriendshipUpdateManyMutationInput, FriendshipUncheckedUpdateManyWithoutToFrienshipInput>
  }

  export type UserUpsertWithWhereUniqueWithoutBlockedByUsersInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutBlockedByUsersInput, UserUncheckedUpdateWithoutBlockedByUsersInput>
    create: XOR<UserCreateWithoutBlockedByUsersInput, UserUncheckedCreateWithoutBlockedByUsersInput>
  }

  export type UserUpdateWithWhereUniqueWithoutBlockedByUsersInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutBlockedByUsersInput, UserUncheckedUpdateWithoutBlockedByUsersInput>
  }

  export type UserUpdateManyWithWhereWithoutBlockedByUsersInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutBlockedUsersInput>
  }

  export type UserScalarWhereInput = {
    AND?: Enumerable<UserScalarWhereInput>
    OR?: Enumerable<UserScalarWhereInput>
    NOT?: Enumerable<UserScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    firstname?: StringFilter | string
    lastname?: StringFilter | string
    email?: StringFilter | string
    avatarS3Key?: StringFilter | string
    coverPicS3Key?: StringFilter | string
  }

  export type UserUpsertWithWhereUniqueWithoutBlockedUsersInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutBlockedUsersInput, UserUncheckedUpdateWithoutBlockedUsersInput>
    create: XOR<UserCreateWithoutBlockedUsersInput, UserUncheckedCreateWithoutBlockedUsersInput>
  }

  export type UserUpdateWithWhereUniqueWithoutBlockedUsersInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutBlockedUsersInput, UserUncheckedUpdateWithoutBlockedUsersInput>
  }

  export type UserUpdateManyWithWhereWithoutBlockedUsersInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutBlockedByUsersInput>
  }

  export type ConversationUpsertWithWhereUniqueWithoutFromInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutFromInput, ConversationUncheckedUpdateWithoutFromInput>
    create: XOR<ConversationCreateWithoutFromInput, ConversationUncheckedCreateWithoutFromInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutFromInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutFromInput, ConversationUncheckedUpdateWithoutFromInput>
  }

  export type ConversationUpdateManyWithWhereWithoutFromInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutConversationsSentInput>
  }

  export type ConversationScalarWhereInput = {
    AND?: Enumerable<ConversationScalarWhereInput>
    OR?: Enumerable<ConversationScalarWhereInput>
    NOT?: Enumerable<ConversationScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    fromId?: IntFilter | number
    toId?: IntNullableFilter | number | null
  }

  export type ConversationUpsertWithWhereUniqueWithoutToInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutToInput, ConversationUncheckedUpdateWithoutToInput>
    create: XOR<ConversationCreateWithoutToInput, ConversationUncheckedCreateWithoutToInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutToInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutToInput, ConversationUncheckedUpdateWithoutToInput>
  }

  export type ConversationUpdateManyWithWhereWithoutToInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutConversationsReceivedInput>
  }

  export type ConversationMessageUpsertWithWhereUniqueWithoutFromInput = {
    where: ConversationMessageWhereUniqueInput
    update: XOR<ConversationMessageUpdateWithoutFromInput, ConversationMessageUncheckedUpdateWithoutFromInput>
    create: XOR<ConversationMessageCreateWithoutFromInput, ConversationMessageUncheckedCreateWithoutFromInput>
  }

  export type ConversationMessageUpdateWithWhereUniqueWithoutFromInput = {
    where: ConversationMessageWhereUniqueInput
    data: XOR<ConversationMessageUpdateWithoutFromInput, ConversationMessageUncheckedUpdateWithoutFromInput>
  }

  export type ConversationMessageUpdateManyWithWhereWithoutFromInput = {
    where: ConversationMessageScalarWhereInput
    data: XOR<ConversationMessageUpdateManyMutationInput, ConversationMessageUncheckedUpdateManyWithoutConversationMessagesInput>
  }

  export type ConversationMessageScalarWhereInput = {
    AND?: Enumerable<ConversationMessageScalarWhereInput>
    OR?: Enumerable<ConversationMessageScalarWhereInput>
    NOT?: Enumerable<ConversationMessageScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    conversationId?: IntNullableFilter | number | null
    userId?: IntFilter | number
  }

  export type UserCreateWithoutPostsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    firstname: string
    lastname: string
    email: string
    avatarS3Key: string
    coverPicS3Key: string
    PostLikes?: PostLikeCreateNestedManyWithoutUserInput
    PostComment?: PostCommentCreateNestedManyWithoutUserInput
    FromFriendship?: FriendshipCreateNestedManyWithoutFromInput
    ToFrienship?: FriendshipCreateNestedManyWithoutToInput
    BlockedUsers?: UserCreateNestedManyWithoutBlockedByUsersInput
    BlockedByUsers?: UserCreateNestedManyWithoutBlockedUsersInput
    ConversationsSent?: ConversationCreateNestedManyWithoutFromInput
    ConversationsReceived?: ConversationCreateNestedManyWithoutToInput
    ConversationMessages?: ConversationMessageCreateNestedManyWithoutFromInput
  }

  export type UserUncheckedCreateWithoutPostsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    firstname: string
    lastname: string
    email: string
    avatarS3Key: string
    coverPicS3Key: string
    PostLikes?: PostLikeUncheckedCreateNestedManyWithoutUserInput
    PostComment?: PostCommentUncheckedCreateNestedManyWithoutUserInput
    FromFriendship?: FriendshipUncheckedCreateNestedManyWithoutFromInput
    ToFrienship?: FriendshipUncheckedCreateNestedManyWithoutToInput
    BlockedUsers?: UserUncheckedCreateNestedManyWithoutBlockedByUsersInput
    BlockedByUsers?: UserUncheckedCreateNestedManyWithoutBlockedUsersInput
    ConversationsSent?: ConversationUncheckedCreateNestedManyWithoutFromInput
    ConversationsReceived?: ConversationUncheckedCreateNestedManyWithoutToInput
    ConversationMessages?: ConversationMessageUncheckedCreateNestedManyWithoutFromInput
  }

  export type UserCreateOrConnectWithoutPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
  }

  export type PostLikeCreateWithoutPostInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutPostLikesInput
  }

  export type PostLikeUncheckedCreateWithoutPostInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
  }

  export type PostLikeCreateOrConnectWithoutPostInput = {
    where: PostLikeWhereUniqueInput
    create: XOR<PostLikeCreateWithoutPostInput, PostLikeUncheckedCreateWithoutPostInput>
  }

  export type PostLikeCreateManyPostInputEnvelope = {
    data: Enumerable<PostLikeCreateManyPostInput>
    skipDuplicates?: boolean
  }

  export type PostCommentCreateWithoutPostInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    User: UserCreateNestedOneWithoutPostCommentInput
    text: string
  }

  export type PostCommentUncheckedCreateWithoutPostInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    text: string
  }

  export type PostCommentCreateOrConnectWithoutPostInput = {
    where: PostCommentWhereUniqueInput
    create: XOR<PostCommentCreateWithoutPostInput, PostCommentUncheckedCreateWithoutPostInput>
  }

  export type PostCommentCreateManyPostInputEnvelope = {
    data: Enumerable<PostCommentCreateManyPostInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPostsInput = {
    update: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
  }

  export type UserUpdateWithoutPostsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatarS3Key?: StringFieldUpdateOperationsInput | string
    coverPicS3Key?: StringFieldUpdateOperationsInput | string
    PostLikes?: PostLikeUpdateManyWithoutUserNestedInput
    PostComment?: PostCommentUpdateManyWithoutUserNestedInput
    FromFriendship?: FriendshipUpdateManyWithoutFromNestedInput
    ToFrienship?: FriendshipUpdateManyWithoutToNestedInput
    BlockedUsers?: UserUpdateManyWithoutBlockedByUsersNestedInput
    BlockedByUsers?: UserUpdateManyWithoutBlockedUsersNestedInput
    ConversationsSent?: ConversationUpdateManyWithoutFromNestedInput
    ConversationsReceived?: ConversationUpdateManyWithoutToNestedInput
    ConversationMessages?: ConversationMessageUpdateManyWithoutFromNestedInput
  }

  export type UserUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatarS3Key?: StringFieldUpdateOperationsInput | string
    coverPicS3Key?: StringFieldUpdateOperationsInput | string
    PostLikes?: PostLikeUncheckedUpdateManyWithoutUserNestedInput
    PostComment?: PostCommentUncheckedUpdateManyWithoutUserNestedInput
    FromFriendship?: FriendshipUncheckedUpdateManyWithoutFromNestedInput
    ToFrienship?: FriendshipUncheckedUpdateManyWithoutToNestedInput
    BlockedUsers?: UserUncheckedUpdateManyWithoutBlockedByUsersNestedInput
    BlockedByUsers?: UserUncheckedUpdateManyWithoutBlockedUsersNestedInput
    ConversationsSent?: ConversationUncheckedUpdateManyWithoutFromNestedInput
    ConversationsReceived?: ConversationUncheckedUpdateManyWithoutToNestedInput
    ConversationMessages?: ConversationMessageUncheckedUpdateManyWithoutFromNestedInput
  }

  export type PostLikeUpsertWithWhereUniqueWithoutPostInput = {
    where: PostLikeWhereUniqueInput
    update: XOR<PostLikeUpdateWithoutPostInput, PostLikeUncheckedUpdateWithoutPostInput>
    create: XOR<PostLikeCreateWithoutPostInput, PostLikeUncheckedCreateWithoutPostInput>
  }

  export type PostLikeUpdateWithWhereUniqueWithoutPostInput = {
    where: PostLikeWhereUniqueInput
    data: XOR<PostLikeUpdateWithoutPostInput, PostLikeUncheckedUpdateWithoutPostInput>
  }

  export type PostLikeUpdateManyWithWhereWithoutPostInput = {
    where: PostLikeScalarWhereInput
    data: XOR<PostLikeUpdateManyMutationInput, PostLikeUncheckedUpdateManyWithoutPostLikesInput>
  }

  export type PostCommentUpsertWithWhereUniqueWithoutPostInput = {
    where: PostCommentWhereUniqueInput
    update: XOR<PostCommentUpdateWithoutPostInput, PostCommentUncheckedUpdateWithoutPostInput>
    create: XOR<PostCommentCreateWithoutPostInput, PostCommentUncheckedCreateWithoutPostInput>
  }

  export type PostCommentUpdateWithWhereUniqueWithoutPostInput = {
    where: PostCommentWhereUniqueInput
    data: XOR<PostCommentUpdateWithoutPostInput, PostCommentUncheckedUpdateWithoutPostInput>
  }

  export type PostCommentUpdateManyWithWhereWithoutPostInput = {
    where: PostCommentScalarWhereInput
    data: XOR<PostCommentUpdateManyMutationInput, PostCommentUncheckedUpdateManyWithoutPostCommentsInput>
  }

  export type UserCreateWithoutPostLikesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    firstname: string
    lastname: string
    email: string
    avatarS3Key: string
    coverPicS3Key: string
    Posts?: PostCreateNestedManyWithoutUserInput
    PostComment?: PostCommentCreateNestedManyWithoutUserInput
    FromFriendship?: FriendshipCreateNestedManyWithoutFromInput
    ToFrienship?: FriendshipCreateNestedManyWithoutToInput
    BlockedUsers?: UserCreateNestedManyWithoutBlockedByUsersInput
    BlockedByUsers?: UserCreateNestedManyWithoutBlockedUsersInput
    ConversationsSent?: ConversationCreateNestedManyWithoutFromInput
    ConversationsReceived?: ConversationCreateNestedManyWithoutToInput
    ConversationMessages?: ConversationMessageCreateNestedManyWithoutFromInput
  }

  export type UserUncheckedCreateWithoutPostLikesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    firstname: string
    lastname: string
    email: string
    avatarS3Key: string
    coverPicS3Key: string
    Posts?: PostUncheckedCreateNestedManyWithoutUserInput
    PostComment?: PostCommentUncheckedCreateNestedManyWithoutUserInput
    FromFriendship?: FriendshipUncheckedCreateNestedManyWithoutFromInput
    ToFrienship?: FriendshipUncheckedCreateNestedManyWithoutToInput
    BlockedUsers?: UserUncheckedCreateNestedManyWithoutBlockedByUsersInput
    BlockedByUsers?: UserUncheckedCreateNestedManyWithoutBlockedUsersInput
    ConversationsSent?: ConversationUncheckedCreateNestedManyWithoutFromInput
    ConversationsReceived?: ConversationUncheckedCreateNestedManyWithoutToInput
    ConversationMessages?: ConversationMessageUncheckedCreateNestedManyWithoutFromInput
  }

  export type UserCreateOrConnectWithoutPostLikesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostLikesInput, UserUncheckedCreateWithoutPostLikesInput>
  }

  export type PostCreateWithoutPostLikesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    htmlContent: string
    User: UserCreateNestedOneWithoutPostsInput
    PostComments?: PostCommentCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutPostLikesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    htmlContent: string
    userId: number
    PostComments?: PostCommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutPostLikesInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutPostLikesInput, PostUncheckedCreateWithoutPostLikesInput>
  }

  export type UserUpsertWithoutPostLikesInput = {
    update: XOR<UserUpdateWithoutPostLikesInput, UserUncheckedUpdateWithoutPostLikesInput>
    create: XOR<UserCreateWithoutPostLikesInput, UserUncheckedCreateWithoutPostLikesInput>
  }

  export type UserUpdateWithoutPostLikesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatarS3Key?: StringFieldUpdateOperationsInput | string
    coverPicS3Key?: StringFieldUpdateOperationsInput | string
    Posts?: PostUpdateManyWithoutUserNestedInput
    PostComment?: PostCommentUpdateManyWithoutUserNestedInput
    FromFriendship?: FriendshipUpdateManyWithoutFromNestedInput
    ToFrienship?: FriendshipUpdateManyWithoutToNestedInput
    BlockedUsers?: UserUpdateManyWithoutBlockedByUsersNestedInput
    BlockedByUsers?: UserUpdateManyWithoutBlockedUsersNestedInput
    ConversationsSent?: ConversationUpdateManyWithoutFromNestedInput
    ConversationsReceived?: ConversationUpdateManyWithoutToNestedInput
    ConversationMessages?: ConversationMessageUpdateManyWithoutFromNestedInput
  }

  export type UserUncheckedUpdateWithoutPostLikesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatarS3Key?: StringFieldUpdateOperationsInput | string
    coverPicS3Key?: StringFieldUpdateOperationsInput | string
    Posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    PostComment?: PostCommentUncheckedUpdateManyWithoutUserNestedInput
    FromFriendship?: FriendshipUncheckedUpdateManyWithoutFromNestedInput
    ToFrienship?: FriendshipUncheckedUpdateManyWithoutToNestedInput
    BlockedUsers?: UserUncheckedUpdateManyWithoutBlockedByUsersNestedInput
    BlockedByUsers?: UserUncheckedUpdateManyWithoutBlockedUsersNestedInput
    ConversationsSent?: ConversationUncheckedUpdateManyWithoutFromNestedInput
    ConversationsReceived?: ConversationUncheckedUpdateManyWithoutToNestedInput
    ConversationMessages?: ConversationMessageUncheckedUpdateManyWithoutFromNestedInput
  }

  export type PostUpsertWithoutPostLikesInput = {
    update: XOR<PostUpdateWithoutPostLikesInput, PostUncheckedUpdateWithoutPostLikesInput>
    create: XOR<PostCreateWithoutPostLikesInput, PostUncheckedCreateWithoutPostLikesInput>
  }

  export type PostUpdateWithoutPostLikesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    htmlContent?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneRequiredWithoutPostsNestedInput
    PostComments?: PostCommentUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutPostLikesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    htmlContent?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    PostComments?: PostCommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type UserCreateWithoutPostCommentInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    firstname: string
    lastname: string
    email: string
    avatarS3Key: string
    coverPicS3Key: string
    Posts?: PostCreateNestedManyWithoutUserInput
    PostLikes?: PostLikeCreateNestedManyWithoutUserInput
    FromFriendship?: FriendshipCreateNestedManyWithoutFromInput
    ToFrienship?: FriendshipCreateNestedManyWithoutToInput
    BlockedUsers?: UserCreateNestedManyWithoutBlockedByUsersInput
    BlockedByUsers?: UserCreateNestedManyWithoutBlockedUsersInput
    ConversationsSent?: ConversationCreateNestedManyWithoutFromInput
    ConversationsReceived?: ConversationCreateNestedManyWithoutToInput
    ConversationMessages?: ConversationMessageCreateNestedManyWithoutFromInput
  }

  export type UserUncheckedCreateWithoutPostCommentInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    firstname: string
    lastname: string
    email: string
    avatarS3Key: string
    coverPicS3Key: string
    Posts?: PostUncheckedCreateNestedManyWithoutUserInput
    PostLikes?: PostLikeUncheckedCreateNestedManyWithoutUserInput
    FromFriendship?: FriendshipUncheckedCreateNestedManyWithoutFromInput
    ToFrienship?: FriendshipUncheckedCreateNestedManyWithoutToInput
    BlockedUsers?: UserUncheckedCreateNestedManyWithoutBlockedByUsersInput
    BlockedByUsers?: UserUncheckedCreateNestedManyWithoutBlockedUsersInput
    ConversationsSent?: ConversationUncheckedCreateNestedManyWithoutFromInput
    ConversationsReceived?: ConversationUncheckedCreateNestedManyWithoutToInput
    ConversationMessages?: ConversationMessageUncheckedCreateNestedManyWithoutFromInput
  }

  export type UserCreateOrConnectWithoutPostCommentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostCommentInput, UserUncheckedCreateWithoutPostCommentInput>
  }

  export type PostCreateWithoutPostCommentsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    htmlContent: string
    User: UserCreateNestedOneWithoutPostsInput
    PostLikes?: PostLikeCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutPostCommentsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    htmlContent: string
    userId: number
    PostLikes?: PostLikeUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutPostCommentsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutPostCommentsInput, PostUncheckedCreateWithoutPostCommentsInput>
  }

  export type UserUpsertWithoutPostCommentInput = {
    update: XOR<UserUpdateWithoutPostCommentInput, UserUncheckedUpdateWithoutPostCommentInput>
    create: XOR<UserCreateWithoutPostCommentInput, UserUncheckedCreateWithoutPostCommentInput>
  }

  export type UserUpdateWithoutPostCommentInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatarS3Key?: StringFieldUpdateOperationsInput | string
    coverPicS3Key?: StringFieldUpdateOperationsInput | string
    Posts?: PostUpdateManyWithoutUserNestedInput
    PostLikes?: PostLikeUpdateManyWithoutUserNestedInput
    FromFriendship?: FriendshipUpdateManyWithoutFromNestedInput
    ToFrienship?: FriendshipUpdateManyWithoutToNestedInput
    BlockedUsers?: UserUpdateManyWithoutBlockedByUsersNestedInput
    BlockedByUsers?: UserUpdateManyWithoutBlockedUsersNestedInput
    ConversationsSent?: ConversationUpdateManyWithoutFromNestedInput
    ConversationsReceived?: ConversationUpdateManyWithoutToNestedInput
    ConversationMessages?: ConversationMessageUpdateManyWithoutFromNestedInput
  }

  export type UserUncheckedUpdateWithoutPostCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatarS3Key?: StringFieldUpdateOperationsInput | string
    coverPicS3Key?: StringFieldUpdateOperationsInput | string
    Posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    PostLikes?: PostLikeUncheckedUpdateManyWithoutUserNestedInput
    FromFriendship?: FriendshipUncheckedUpdateManyWithoutFromNestedInput
    ToFrienship?: FriendshipUncheckedUpdateManyWithoutToNestedInput
    BlockedUsers?: UserUncheckedUpdateManyWithoutBlockedByUsersNestedInput
    BlockedByUsers?: UserUncheckedUpdateManyWithoutBlockedUsersNestedInput
    ConversationsSent?: ConversationUncheckedUpdateManyWithoutFromNestedInput
    ConversationsReceived?: ConversationUncheckedUpdateManyWithoutToNestedInput
    ConversationMessages?: ConversationMessageUncheckedUpdateManyWithoutFromNestedInput
  }

  export type PostUpsertWithoutPostCommentsInput = {
    update: XOR<PostUpdateWithoutPostCommentsInput, PostUncheckedUpdateWithoutPostCommentsInput>
    create: XOR<PostCreateWithoutPostCommentsInput, PostUncheckedCreateWithoutPostCommentsInput>
  }

  export type PostUpdateWithoutPostCommentsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    htmlContent?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneRequiredWithoutPostsNestedInput
    PostLikes?: PostLikeUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutPostCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    htmlContent?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    PostLikes?: PostLikeUncheckedUpdateManyWithoutPostNestedInput
  }

  export type UserCreateWithoutFromFriendshipInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    firstname: string
    lastname: string
    email: string
    avatarS3Key: string
    coverPicS3Key: string
    Posts?: PostCreateNestedManyWithoutUserInput
    PostLikes?: PostLikeCreateNestedManyWithoutUserInput
    PostComment?: PostCommentCreateNestedManyWithoutUserInput
    ToFrienship?: FriendshipCreateNestedManyWithoutToInput
    BlockedUsers?: UserCreateNestedManyWithoutBlockedByUsersInput
    BlockedByUsers?: UserCreateNestedManyWithoutBlockedUsersInput
    ConversationsSent?: ConversationCreateNestedManyWithoutFromInput
    ConversationsReceived?: ConversationCreateNestedManyWithoutToInput
    ConversationMessages?: ConversationMessageCreateNestedManyWithoutFromInput
  }

  export type UserUncheckedCreateWithoutFromFriendshipInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    firstname: string
    lastname: string
    email: string
    avatarS3Key: string
    coverPicS3Key: string
    Posts?: PostUncheckedCreateNestedManyWithoutUserInput
    PostLikes?: PostLikeUncheckedCreateNestedManyWithoutUserInput
    PostComment?: PostCommentUncheckedCreateNestedManyWithoutUserInput
    ToFrienship?: FriendshipUncheckedCreateNestedManyWithoutToInput
    BlockedUsers?: UserUncheckedCreateNestedManyWithoutBlockedByUsersInput
    BlockedByUsers?: UserUncheckedCreateNestedManyWithoutBlockedUsersInput
    ConversationsSent?: ConversationUncheckedCreateNestedManyWithoutFromInput
    ConversationsReceived?: ConversationUncheckedCreateNestedManyWithoutToInput
    ConversationMessages?: ConversationMessageUncheckedCreateNestedManyWithoutFromInput
  }

  export type UserCreateOrConnectWithoutFromFriendshipInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFromFriendshipInput, UserUncheckedCreateWithoutFromFriendshipInput>
  }

  export type UserCreateWithoutToFrienshipInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    firstname: string
    lastname: string
    email: string
    avatarS3Key: string
    coverPicS3Key: string
    Posts?: PostCreateNestedManyWithoutUserInput
    PostLikes?: PostLikeCreateNestedManyWithoutUserInput
    PostComment?: PostCommentCreateNestedManyWithoutUserInput
    FromFriendship?: FriendshipCreateNestedManyWithoutFromInput
    BlockedUsers?: UserCreateNestedManyWithoutBlockedByUsersInput
    BlockedByUsers?: UserCreateNestedManyWithoutBlockedUsersInput
    ConversationsSent?: ConversationCreateNestedManyWithoutFromInput
    ConversationsReceived?: ConversationCreateNestedManyWithoutToInput
    ConversationMessages?: ConversationMessageCreateNestedManyWithoutFromInput
  }

  export type UserUncheckedCreateWithoutToFrienshipInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    firstname: string
    lastname: string
    email: string
    avatarS3Key: string
    coverPicS3Key: string
    Posts?: PostUncheckedCreateNestedManyWithoutUserInput
    PostLikes?: PostLikeUncheckedCreateNestedManyWithoutUserInput
    PostComment?: PostCommentUncheckedCreateNestedManyWithoutUserInput
    FromFriendship?: FriendshipUncheckedCreateNestedManyWithoutFromInput
    BlockedUsers?: UserUncheckedCreateNestedManyWithoutBlockedByUsersInput
    BlockedByUsers?: UserUncheckedCreateNestedManyWithoutBlockedUsersInput
    ConversationsSent?: ConversationUncheckedCreateNestedManyWithoutFromInput
    ConversationsReceived?: ConversationUncheckedCreateNestedManyWithoutToInput
    ConversationMessages?: ConversationMessageUncheckedCreateNestedManyWithoutFromInput
  }

  export type UserCreateOrConnectWithoutToFrienshipInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutToFrienshipInput, UserUncheckedCreateWithoutToFrienshipInput>
  }

  export type NotificationCreateWithoutFriendshipInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    read?: boolean
    Message?: ConversationMessageCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUncheckedCreateWithoutFriendshipInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    read?: boolean
    conversationMessageId?: number | null
  }

  export type NotificationCreateOrConnectWithoutFriendshipInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutFriendshipInput, NotificationUncheckedCreateWithoutFriendshipInput>
  }

  export type NotificationCreateManyFriendshipInputEnvelope = {
    data: Enumerable<NotificationCreateManyFriendshipInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutFromFriendshipInput = {
    update: XOR<UserUpdateWithoutFromFriendshipInput, UserUncheckedUpdateWithoutFromFriendshipInput>
    create: XOR<UserCreateWithoutFromFriendshipInput, UserUncheckedCreateWithoutFromFriendshipInput>
  }

  export type UserUpdateWithoutFromFriendshipInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatarS3Key?: StringFieldUpdateOperationsInput | string
    coverPicS3Key?: StringFieldUpdateOperationsInput | string
    Posts?: PostUpdateManyWithoutUserNestedInput
    PostLikes?: PostLikeUpdateManyWithoutUserNestedInput
    PostComment?: PostCommentUpdateManyWithoutUserNestedInput
    ToFrienship?: FriendshipUpdateManyWithoutToNestedInput
    BlockedUsers?: UserUpdateManyWithoutBlockedByUsersNestedInput
    BlockedByUsers?: UserUpdateManyWithoutBlockedUsersNestedInput
    ConversationsSent?: ConversationUpdateManyWithoutFromNestedInput
    ConversationsReceived?: ConversationUpdateManyWithoutToNestedInput
    ConversationMessages?: ConversationMessageUpdateManyWithoutFromNestedInput
  }

  export type UserUncheckedUpdateWithoutFromFriendshipInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatarS3Key?: StringFieldUpdateOperationsInput | string
    coverPicS3Key?: StringFieldUpdateOperationsInput | string
    Posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    PostLikes?: PostLikeUncheckedUpdateManyWithoutUserNestedInput
    PostComment?: PostCommentUncheckedUpdateManyWithoutUserNestedInput
    ToFrienship?: FriendshipUncheckedUpdateManyWithoutToNestedInput
    BlockedUsers?: UserUncheckedUpdateManyWithoutBlockedByUsersNestedInput
    BlockedByUsers?: UserUncheckedUpdateManyWithoutBlockedUsersNestedInput
    ConversationsSent?: ConversationUncheckedUpdateManyWithoutFromNestedInput
    ConversationsReceived?: ConversationUncheckedUpdateManyWithoutToNestedInput
    ConversationMessages?: ConversationMessageUncheckedUpdateManyWithoutFromNestedInput
  }

  export type UserUpsertWithoutToFrienshipInput = {
    update: XOR<UserUpdateWithoutToFrienshipInput, UserUncheckedUpdateWithoutToFrienshipInput>
    create: XOR<UserCreateWithoutToFrienshipInput, UserUncheckedCreateWithoutToFrienshipInput>
  }

  export type UserUpdateWithoutToFrienshipInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatarS3Key?: StringFieldUpdateOperationsInput | string
    coverPicS3Key?: StringFieldUpdateOperationsInput | string
    Posts?: PostUpdateManyWithoutUserNestedInput
    PostLikes?: PostLikeUpdateManyWithoutUserNestedInput
    PostComment?: PostCommentUpdateManyWithoutUserNestedInput
    FromFriendship?: FriendshipUpdateManyWithoutFromNestedInput
    BlockedUsers?: UserUpdateManyWithoutBlockedByUsersNestedInput
    BlockedByUsers?: UserUpdateManyWithoutBlockedUsersNestedInput
    ConversationsSent?: ConversationUpdateManyWithoutFromNestedInput
    ConversationsReceived?: ConversationUpdateManyWithoutToNestedInput
    ConversationMessages?: ConversationMessageUpdateManyWithoutFromNestedInput
  }

  export type UserUncheckedUpdateWithoutToFrienshipInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatarS3Key?: StringFieldUpdateOperationsInput | string
    coverPicS3Key?: StringFieldUpdateOperationsInput | string
    Posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    PostLikes?: PostLikeUncheckedUpdateManyWithoutUserNestedInput
    PostComment?: PostCommentUncheckedUpdateManyWithoutUserNestedInput
    FromFriendship?: FriendshipUncheckedUpdateManyWithoutFromNestedInput
    BlockedUsers?: UserUncheckedUpdateManyWithoutBlockedByUsersNestedInput
    BlockedByUsers?: UserUncheckedUpdateManyWithoutBlockedUsersNestedInput
    ConversationsSent?: ConversationUncheckedUpdateManyWithoutFromNestedInput
    ConversationsReceived?: ConversationUncheckedUpdateManyWithoutToNestedInput
    ConversationMessages?: ConversationMessageUncheckedUpdateManyWithoutFromNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutFriendshipInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutFriendshipInput, NotificationUncheckedUpdateWithoutFriendshipInput>
    create: XOR<NotificationCreateWithoutFriendshipInput, NotificationUncheckedCreateWithoutFriendshipInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutFriendshipInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutFriendshipInput, NotificationUncheckedUpdateWithoutFriendshipInput>
  }

  export type NotificationUpdateManyWithWhereWithoutFriendshipInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutNotificationInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: Enumerable<NotificationScalarWhereInput>
    OR?: Enumerable<NotificationScalarWhereInput>
    NOT?: Enumerable<NotificationScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    read?: BoolFilter | boolean
    friendshipId?: IntNullableFilter | number | null
    conversationMessageId?: IntNullableFilter | number | null
  }

  export type UserCreateWithoutConversationsSentInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    firstname: string
    lastname: string
    email: string
    avatarS3Key: string
    coverPicS3Key: string
    Posts?: PostCreateNestedManyWithoutUserInput
    PostLikes?: PostLikeCreateNestedManyWithoutUserInput
    PostComment?: PostCommentCreateNestedManyWithoutUserInput
    FromFriendship?: FriendshipCreateNestedManyWithoutFromInput
    ToFrienship?: FriendshipCreateNestedManyWithoutToInput
    BlockedUsers?: UserCreateNestedManyWithoutBlockedByUsersInput
    BlockedByUsers?: UserCreateNestedManyWithoutBlockedUsersInput
    ConversationsReceived?: ConversationCreateNestedManyWithoutToInput
    ConversationMessages?: ConversationMessageCreateNestedManyWithoutFromInput
  }

  export type UserUncheckedCreateWithoutConversationsSentInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    firstname: string
    lastname: string
    email: string
    avatarS3Key: string
    coverPicS3Key: string
    Posts?: PostUncheckedCreateNestedManyWithoutUserInput
    PostLikes?: PostLikeUncheckedCreateNestedManyWithoutUserInput
    PostComment?: PostCommentUncheckedCreateNestedManyWithoutUserInput
    FromFriendship?: FriendshipUncheckedCreateNestedManyWithoutFromInput
    ToFrienship?: FriendshipUncheckedCreateNestedManyWithoutToInput
    BlockedUsers?: UserUncheckedCreateNestedManyWithoutBlockedByUsersInput
    BlockedByUsers?: UserUncheckedCreateNestedManyWithoutBlockedUsersInput
    ConversationsReceived?: ConversationUncheckedCreateNestedManyWithoutToInput
    ConversationMessages?: ConversationMessageUncheckedCreateNestedManyWithoutFromInput
  }

  export type UserCreateOrConnectWithoutConversationsSentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConversationsSentInput, UserUncheckedCreateWithoutConversationsSentInput>
  }

  export type UserCreateWithoutConversationsReceivedInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    firstname: string
    lastname: string
    email: string
    avatarS3Key: string
    coverPicS3Key: string
    Posts?: PostCreateNestedManyWithoutUserInput
    PostLikes?: PostLikeCreateNestedManyWithoutUserInput
    PostComment?: PostCommentCreateNestedManyWithoutUserInput
    FromFriendship?: FriendshipCreateNestedManyWithoutFromInput
    ToFrienship?: FriendshipCreateNestedManyWithoutToInput
    BlockedUsers?: UserCreateNestedManyWithoutBlockedByUsersInput
    BlockedByUsers?: UserCreateNestedManyWithoutBlockedUsersInput
    ConversationsSent?: ConversationCreateNestedManyWithoutFromInput
    ConversationMessages?: ConversationMessageCreateNestedManyWithoutFromInput
  }

  export type UserUncheckedCreateWithoutConversationsReceivedInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    firstname: string
    lastname: string
    email: string
    avatarS3Key: string
    coverPicS3Key: string
    Posts?: PostUncheckedCreateNestedManyWithoutUserInput
    PostLikes?: PostLikeUncheckedCreateNestedManyWithoutUserInput
    PostComment?: PostCommentUncheckedCreateNestedManyWithoutUserInput
    FromFriendship?: FriendshipUncheckedCreateNestedManyWithoutFromInput
    ToFrienship?: FriendshipUncheckedCreateNestedManyWithoutToInput
    BlockedUsers?: UserUncheckedCreateNestedManyWithoutBlockedByUsersInput
    BlockedByUsers?: UserUncheckedCreateNestedManyWithoutBlockedUsersInput
    ConversationsSent?: ConversationUncheckedCreateNestedManyWithoutFromInput
    ConversationMessages?: ConversationMessageUncheckedCreateNestedManyWithoutFromInput
  }

  export type UserCreateOrConnectWithoutConversationsReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConversationsReceivedInput, UserUncheckedCreateWithoutConversationsReceivedInput>
  }

  export type ConversationMessageCreateWithoutConversationInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    From: UserCreateNestedOneWithoutConversationMessagesInput
    Notification?: NotificationCreateNestedManyWithoutMessageInput
  }

  export type ConversationMessageUncheckedCreateWithoutConversationInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    Notification?: NotificationUncheckedCreateNestedManyWithoutMessageInput
  }

  export type ConversationMessageCreateOrConnectWithoutConversationInput = {
    where: ConversationMessageWhereUniqueInput
    create: XOR<ConversationMessageCreateWithoutConversationInput, ConversationMessageUncheckedCreateWithoutConversationInput>
  }

  export type ConversationMessageCreateManyConversationInputEnvelope = {
    data: Enumerable<ConversationMessageCreateManyConversationInput>
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutConversationsSentInput = {
    update: XOR<UserUpdateWithoutConversationsSentInput, UserUncheckedUpdateWithoutConversationsSentInput>
    create: XOR<UserCreateWithoutConversationsSentInput, UserUncheckedCreateWithoutConversationsSentInput>
  }

  export type UserUpdateWithoutConversationsSentInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatarS3Key?: StringFieldUpdateOperationsInput | string
    coverPicS3Key?: StringFieldUpdateOperationsInput | string
    Posts?: PostUpdateManyWithoutUserNestedInput
    PostLikes?: PostLikeUpdateManyWithoutUserNestedInput
    PostComment?: PostCommentUpdateManyWithoutUserNestedInput
    FromFriendship?: FriendshipUpdateManyWithoutFromNestedInput
    ToFrienship?: FriendshipUpdateManyWithoutToNestedInput
    BlockedUsers?: UserUpdateManyWithoutBlockedByUsersNestedInput
    BlockedByUsers?: UserUpdateManyWithoutBlockedUsersNestedInput
    ConversationsReceived?: ConversationUpdateManyWithoutToNestedInput
    ConversationMessages?: ConversationMessageUpdateManyWithoutFromNestedInput
  }

  export type UserUncheckedUpdateWithoutConversationsSentInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatarS3Key?: StringFieldUpdateOperationsInput | string
    coverPicS3Key?: StringFieldUpdateOperationsInput | string
    Posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    PostLikes?: PostLikeUncheckedUpdateManyWithoutUserNestedInput
    PostComment?: PostCommentUncheckedUpdateManyWithoutUserNestedInput
    FromFriendship?: FriendshipUncheckedUpdateManyWithoutFromNestedInput
    ToFrienship?: FriendshipUncheckedUpdateManyWithoutToNestedInput
    BlockedUsers?: UserUncheckedUpdateManyWithoutBlockedByUsersNestedInput
    BlockedByUsers?: UserUncheckedUpdateManyWithoutBlockedUsersNestedInput
    ConversationsReceived?: ConversationUncheckedUpdateManyWithoutToNestedInput
    ConversationMessages?: ConversationMessageUncheckedUpdateManyWithoutFromNestedInput
  }

  export type UserUpsertWithoutConversationsReceivedInput = {
    update: XOR<UserUpdateWithoutConversationsReceivedInput, UserUncheckedUpdateWithoutConversationsReceivedInput>
    create: XOR<UserCreateWithoutConversationsReceivedInput, UserUncheckedCreateWithoutConversationsReceivedInput>
  }

  export type UserUpdateWithoutConversationsReceivedInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatarS3Key?: StringFieldUpdateOperationsInput | string
    coverPicS3Key?: StringFieldUpdateOperationsInput | string
    Posts?: PostUpdateManyWithoutUserNestedInput
    PostLikes?: PostLikeUpdateManyWithoutUserNestedInput
    PostComment?: PostCommentUpdateManyWithoutUserNestedInput
    FromFriendship?: FriendshipUpdateManyWithoutFromNestedInput
    ToFrienship?: FriendshipUpdateManyWithoutToNestedInput
    BlockedUsers?: UserUpdateManyWithoutBlockedByUsersNestedInput
    BlockedByUsers?: UserUpdateManyWithoutBlockedUsersNestedInput
    ConversationsSent?: ConversationUpdateManyWithoutFromNestedInput
    ConversationMessages?: ConversationMessageUpdateManyWithoutFromNestedInput
  }

  export type UserUncheckedUpdateWithoutConversationsReceivedInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatarS3Key?: StringFieldUpdateOperationsInput | string
    coverPicS3Key?: StringFieldUpdateOperationsInput | string
    Posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    PostLikes?: PostLikeUncheckedUpdateManyWithoutUserNestedInput
    PostComment?: PostCommentUncheckedUpdateManyWithoutUserNestedInput
    FromFriendship?: FriendshipUncheckedUpdateManyWithoutFromNestedInput
    ToFrienship?: FriendshipUncheckedUpdateManyWithoutToNestedInput
    BlockedUsers?: UserUncheckedUpdateManyWithoutBlockedByUsersNestedInput
    BlockedByUsers?: UserUncheckedUpdateManyWithoutBlockedUsersNestedInput
    ConversationsSent?: ConversationUncheckedUpdateManyWithoutFromNestedInput
    ConversationMessages?: ConversationMessageUncheckedUpdateManyWithoutFromNestedInput
  }

  export type ConversationMessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: ConversationMessageWhereUniqueInput
    update: XOR<ConversationMessageUpdateWithoutConversationInput, ConversationMessageUncheckedUpdateWithoutConversationInput>
    create: XOR<ConversationMessageCreateWithoutConversationInput, ConversationMessageUncheckedCreateWithoutConversationInput>
  }

  export type ConversationMessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: ConversationMessageWhereUniqueInput
    data: XOR<ConversationMessageUpdateWithoutConversationInput, ConversationMessageUncheckedUpdateWithoutConversationInput>
  }

  export type ConversationMessageUpdateManyWithWhereWithoutConversationInput = {
    where: ConversationMessageScalarWhereInput
    data: XOR<ConversationMessageUpdateManyMutationInput, ConversationMessageUncheckedUpdateManyWithoutMessagesInput>
  }

  export type ConversationCreateWithoutMessagesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    From: UserCreateNestedOneWithoutConversationsSentInput
    To?: UserCreateNestedOneWithoutConversationsReceivedInput
  }

  export type ConversationUncheckedCreateWithoutMessagesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    fromId: number
    toId?: number | null
  }

  export type ConversationCreateOrConnectWithoutMessagesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutConversationMessagesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    firstname: string
    lastname: string
    email: string
    avatarS3Key: string
    coverPicS3Key: string
    Posts?: PostCreateNestedManyWithoutUserInput
    PostLikes?: PostLikeCreateNestedManyWithoutUserInput
    PostComment?: PostCommentCreateNestedManyWithoutUserInput
    FromFriendship?: FriendshipCreateNestedManyWithoutFromInput
    ToFrienship?: FriendshipCreateNestedManyWithoutToInput
    BlockedUsers?: UserCreateNestedManyWithoutBlockedByUsersInput
    BlockedByUsers?: UserCreateNestedManyWithoutBlockedUsersInput
    ConversationsSent?: ConversationCreateNestedManyWithoutFromInput
    ConversationsReceived?: ConversationCreateNestedManyWithoutToInput
  }

  export type UserUncheckedCreateWithoutConversationMessagesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    firstname: string
    lastname: string
    email: string
    avatarS3Key: string
    coverPicS3Key: string
    Posts?: PostUncheckedCreateNestedManyWithoutUserInput
    PostLikes?: PostLikeUncheckedCreateNestedManyWithoutUserInput
    PostComment?: PostCommentUncheckedCreateNestedManyWithoutUserInput
    FromFriendship?: FriendshipUncheckedCreateNestedManyWithoutFromInput
    ToFrienship?: FriendshipUncheckedCreateNestedManyWithoutToInput
    BlockedUsers?: UserUncheckedCreateNestedManyWithoutBlockedByUsersInput
    BlockedByUsers?: UserUncheckedCreateNestedManyWithoutBlockedUsersInput
    ConversationsSent?: ConversationUncheckedCreateNestedManyWithoutFromInput
    ConversationsReceived?: ConversationUncheckedCreateNestedManyWithoutToInput
  }

  export type UserCreateOrConnectWithoutConversationMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConversationMessagesInput, UserUncheckedCreateWithoutConversationMessagesInput>
  }

  export type NotificationCreateWithoutMessageInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    read?: boolean
    Friendship?: FriendshipCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUncheckedCreateWithoutMessageInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    read?: boolean
    friendshipId?: number | null
  }

  export type NotificationCreateOrConnectWithoutMessageInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutMessageInput, NotificationUncheckedCreateWithoutMessageInput>
  }

  export type NotificationCreateManyMessageInputEnvelope = {
    data: Enumerable<NotificationCreateManyMessageInput>
    skipDuplicates?: boolean
  }

  export type ConversationUpsertWithoutMessagesInput = {
    update: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
  }

  export type ConversationUpdateWithoutMessagesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    From?: UserUpdateOneRequiredWithoutConversationsSentNestedInput
    To?: UserUpdateOneWithoutConversationsReceivedNestedInput
  }

  export type ConversationUncheckedUpdateWithoutMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromId?: IntFieldUpdateOperationsInput | number
    toId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserUpsertWithoutConversationMessagesInput = {
    update: XOR<UserUpdateWithoutConversationMessagesInput, UserUncheckedUpdateWithoutConversationMessagesInput>
    create: XOR<UserCreateWithoutConversationMessagesInput, UserUncheckedCreateWithoutConversationMessagesInput>
  }

  export type UserUpdateWithoutConversationMessagesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatarS3Key?: StringFieldUpdateOperationsInput | string
    coverPicS3Key?: StringFieldUpdateOperationsInput | string
    Posts?: PostUpdateManyWithoutUserNestedInput
    PostLikes?: PostLikeUpdateManyWithoutUserNestedInput
    PostComment?: PostCommentUpdateManyWithoutUserNestedInput
    FromFriendship?: FriendshipUpdateManyWithoutFromNestedInput
    ToFrienship?: FriendshipUpdateManyWithoutToNestedInput
    BlockedUsers?: UserUpdateManyWithoutBlockedByUsersNestedInput
    BlockedByUsers?: UserUpdateManyWithoutBlockedUsersNestedInput
    ConversationsSent?: ConversationUpdateManyWithoutFromNestedInput
    ConversationsReceived?: ConversationUpdateManyWithoutToNestedInput
  }

  export type UserUncheckedUpdateWithoutConversationMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatarS3Key?: StringFieldUpdateOperationsInput | string
    coverPicS3Key?: StringFieldUpdateOperationsInput | string
    Posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    PostLikes?: PostLikeUncheckedUpdateManyWithoutUserNestedInput
    PostComment?: PostCommentUncheckedUpdateManyWithoutUserNestedInput
    FromFriendship?: FriendshipUncheckedUpdateManyWithoutFromNestedInput
    ToFrienship?: FriendshipUncheckedUpdateManyWithoutToNestedInput
    BlockedUsers?: UserUncheckedUpdateManyWithoutBlockedByUsersNestedInput
    BlockedByUsers?: UserUncheckedUpdateManyWithoutBlockedUsersNestedInput
    ConversationsSent?: ConversationUncheckedUpdateManyWithoutFromNestedInput
    ConversationsReceived?: ConversationUncheckedUpdateManyWithoutToNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutMessageInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutMessageInput, NotificationUncheckedUpdateWithoutMessageInput>
    create: XOR<NotificationCreateWithoutMessageInput, NotificationUncheckedCreateWithoutMessageInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutMessageInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutMessageInput, NotificationUncheckedUpdateWithoutMessageInput>
  }

  export type NotificationUpdateManyWithWhereWithoutMessageInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutNotificationInput>
  }

  export type FriendshipCreateWithoutNotificationInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    from: UserCreateNestedOneWithoutFromFriendshipInput
    to: UserCreateNestedOneWithoutToFrienshipInput
    status?: FriendshipStatus
  }

  export type FriendshipUncheckedCreateWithoutNotificationInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: FriendshipStatus
    fromId: number
    toId: number
  }

  export type FriendshipCreateOrConnectWithoutNotificationInput = {
    where: FriendshipWhereUniqueInput
    create: XOR<FriendshipCreateWithoutNotificationInput, FriendshipUncheckedCreateWithoutNotificationInput>
  }

  export type ConversationMessageCreateWithoutNotificationInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    Conversation?: ConversationCreateNestedOneWithoutMessagesInput
    From: UserCreateNestedOneWithoutConversationMessagesInput
  }

  export type ConversationMessageUncheckedCreateWithoutNotificationInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    conversationId?: number | null
    userId: number
  }

  export type ConversationMessageCreateOrConnectWithoutNotificationInput = {
    where: ConversationMessageWhereUniqueInput
    create: XOR<ConversationMessageCreateWithoutNotificationInput, ConversationMessageUncheckedCreateWithoutNotificationInput>
  }

  export type FriendshipUpsertWithoutNotificationInput = {
    update: XOR<FriendshipUpdateWithoutNotificationInput, FriendshipUncheckedUpdateWithoutNotificationInput>
    create: XOR<FriendshipCreateWithoutNotificationInput, FriendshipUncheckedCreateWithoutNotificationInput>
  }

  export type FriendshipUpdateWithoutNotificationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    from?: UserUpdateOneRequiredWithoutFromFriendshipNestedInput
    to?: UserUpdateOneRequiredWithoutToFrienshipNestedInput
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | FriendshipStatus
  }

  export type FriendshipUncheckedUpdateWithoutNotificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | FriendshipStatus
    fromId?: IntFieldUpdateOperationsInput | number
    toId?: IntFieldUpdateOperationsInput | number
  }

  export type ConversationMessageUpsertWithoutNotificationInput = {
    update: XOR<ConversationMessageUpdateWithoutNotificationInput, ConversationMessageUncheckedUpdateWithoutNotificationInput>
    create: XOR<ConversationMessageCreateWithoutNotificationInput, ConversationMessageUncheckedCreateWithoutNotificationInput>
  }

  export type ConversationMessageUpdateWithoutNotificationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Conversation?: ConversationUpdateOneWithoutMessagesNestedInput
    From?: UserUpdateOneRequiredWithoutConversationMessagesNestedInput
  }

  export type ConversationMessageUncheckedUpdateWithoutNotificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversationId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type PostCreateManyUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    htmlContent: string
  }

  export type PostLikeCreateManyUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    postId: number
  }

  export type PostCommentCreateManyUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    postId: number
    text: string
  }

  export type FriendshipCreateManyFromInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: FriendshipStatus
    toId: number
  }

  export type FriendshipCreateManyToInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: FriendshipStatus
    fromId: number
  }

  export type ConversationCreateManyFromInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    toId?: number | null
  }

  export type ConversationCreateManyToInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    fromId: number
  }

  export type ConversationMessageCreateManyFromInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    conversationId?: number | null
  }

  export type PostUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    htmlContent?: StringFieldUpdateOperationsInput | string
    PostLikes?: PostLikeUpdateManyWithoutPostNestedInput
    PostComments?: PostCommentUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    htmlContent?: StringFieldUpdateOperationsInput | string
    PostLikes?: PostLikeUncheckedUpdateManyWithoutPostNestedInput
    PostComments?: PostCommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    htmlContent?: StringFieldUpdateOperationsInput | string
  }

  export type PostLikeUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Post?: PostUpdateOneRequiredWithoutPostLikesNestedInput
  }

  export type PostLikeUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postId?: IntFieldUpdateOperationsInput | number
  }

  export type PostLikeUncheckedUpdateManyWithoutPostLikesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postId?: IntFieldUpdateOperationsInput | number
  }

  export type PostCommentUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Post?: PostUpdateOneRequiredWithoutPostCommentsNestedInput
    text?: StringFieldUpdateOperationsInput | string
  }

  export type PostCommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
  }

  export type PostCommentUncheckedUpdateManyWithoutPostCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    postId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
  }

  export type FriendshipUpdateWithoutFromInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    to?: UserUpdateOneRequiredWithoutToFrienshipNestedInput
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | FriendshipStatus
    Notification?: NotificationUpdateManyWithoutFriendshipNestedInput
  }

  export type FriendshipUncheckedUpdateWithoutFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | FriendshipStatus
    toId?: IntFieldUpdateOperationsInput | number
    Notification?: NotificationUncheckedUpdateManyWithoutFriendshipNestedInput
  }

  export type FriendshipUncheckedUpdateManyWithoutFromFriendshipInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | FriendshipStatus
    toId?: IntFieldUpdateOperationsInput | number
  }

  export type FriendshipUpdateWithoutToInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    from?: UserUpdateOneRequiredWithoutFromFriendshipNestedInput
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | FriendshipStatus
    Notification?: NotificationUpdateManyWithoutFriendshipNestedInput
  }

  export type FriendshipUncheckedUpdateWithoutToInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | FriendshipStatus
    fromId?: IntFieldUpdateOperationsInput | number
    Notification?: NotificationUncheckedUpdateManyWithoutFriendshipNestedInput
  }

  export type FriendshipUncheckedUpdateManyWithoutToFrienshipInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumFriendshipStatusFieldUpdateOperationsInput | FriendshipStatus
    fromId?: IntFieldUpdateOperationsInput | number
  }

  export type UserUpdateWithoutBlockedByUsersInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatarS3Key?: StringFieldUpdateOperationsInput | string
    coverPicS3Key?: StringFieldUpdateOperationsInput | string
    Posts?: PostUpdateManyWithoutUserNestedInput
    PostLikes?: PostLikeUpdateManyWithoutUserNestedInput
    PostComment?: PostCommentUpdateManyWithoutUserNestedInput
    FromFriendship?: FriendshipUpdateManyWithoutFromNestedInput
    ToFrienship?: FriendshipUpdateManyWithoutToNestedInput
    BlockedUsers?: UserUpdateManyWithoutBlockedByUsersNestedInput
    ConversationsSent?: ConversationUpdateManyWithoutFromNestedInput
    ConversationsReceived?: ConversationUpdateManyWithoutToNestedInput
    ConversationMessages?: ConversationMessageUpdateManyWithoutFromNestedInput
  }

  export type UserUncheckedUpdateWithoutBlockedByUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatarS3Key?: StringFieldUpdateOperationsInput | string
    coverPicS3Key?: StringFieldUpdateOperationsInput | string
    Posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    PostLikes?: PostLikeUncheckedUpdateManyWithoutUserNestedInput
    PostComment?: PostCommentUncheckedUpdateManyWithoutUserNestedInput
    FromFriendship?: FriendshipUncheckedUpdateManyWithoutFromNestedInput
    ToFrienship?: FriendshipUncheckedUpdateManyWithoutToNestedInput
    BlockedUsers?: UserUncheckedUpdateManyWithoutBlockedByUsersNestedInput
    ConversationsSent?: ConversationUncheckedUpdateManyWithoutFromNestedInput
    ConversationsReceived?: ConversationUncheckedUpdateManyWithoutToNestedInput
    ConversationMessages?: ConversationMessageUncheckedUpdateManyWithoutFromNestedInput
  }

  export type UserUncheckedUpdateManyWithoutBlockedUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatarS3Key?: StringFieldUpdateOperationsInput | string
    coverPicS3Key?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpdateWithoutBlockedUsersInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatarS3Key?: StringFieldUpdateOperationsInput | string
    coverPicS3Key?: StringFieldUpdateOperationsInput | string
    Posts?: PostUpdateManyWithoutUserNestedInput
    PostLikes?: PostLikeUpdateManyWithoutUserNestedInput
    PostComment?: PostCommentUpdateManyWithoutUserNestedInput
    FromFriendship?: FriendshipUpdateManyWithoutFromNestedInput
    ToFrienship?: FriendshipUpdateManyWithoutToNestedInput
    BlockedByUsers?: UserUpdateManyWithoutBlockedUsersNestedInput
    ConversationsSent?: ConversationUpdateManyWithoutFromNestedInput
    ConversationsReceived?: ConversationUpdateManyWithoutToNestedInput
    ConversationMessages?: ConversationMessageUpdateManyWithoutFromNestedInput
  }

  export type UserUncheckedUpdateWithoutBlockedUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatarS3Key?: StringFieldUpdateOperationsInput | string
    coverPicS3Key?: StringFieldUpdateOperationsInput | string
    Posts?: PostUncheckedUpdateManyWithoutUserNestedInput
    PostLikes?: PostLikeUncheckedUpdateManyWithoutUserNestedInput
    PostComment?: PostCommentUncheckedUpdateManyWithoutUserNestedInput
    FromFriendship?: FriendshipUncheckedUpdateManyWithoutFromNestedInput
    ToFrienship?: FriendshipUncheckedUpdateManyWithoutToNestedInput
    BlockedByUsers?: UserUncheckedUpdateManyWithoutBlockedUsersNestedInput
    ConversationsSent?: ConversationUncheckedUpdateManyWithoutFromNestedInput
    ConversationsReceived?: ConversationUncheckedUpdateManyWithoutToNestedInput
    ConversationMessages?: ConversationMessageUncheckedUpdateManyWithoutFromNestedInput
  }

  export type UserUncheckedUpdateManyWithoutBlockedByUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    firstname?: StringFieldUpdateOperationsInput | string
    lastname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    avatarS3Key?: StringFieldUpdateOperationsInput | string
    coverPicS3Key?: StringFieldUpdateOperationsInput | string
  }

  export type ConversationUpdateWithoutFromInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    To?: UserUpdateOneWithoutConversationsReceivedNestedInput
    Messages?: ConversationMessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    toId?: NullableIntFieldUpdateOperationsInput | number | null
    Messages?: ConversationMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutConversationsSentInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    toId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ConversationUpdateWithoutToInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    From?: UserUpdateOneRequiredWithoutConversationsSentNestedInput
    Messages?: ConversationMessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutToInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromId?: IntFieldUpdateOperationsInput | number
    Messages?: ConversationMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutConversationsReceivedInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fromId?: IntFieldUpdateOperationsInput | number
  }

  export type ConversationMessageUpdateWithoutFromInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Conversation?: ConversationUpdateOneWithoutMessagesNestedInput
    Notification?: NotificationUpdateManyWithoutMessageNestedInput
  }

  export type ConversationMessageUncheckedUpdateWithoutFromInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversationId?: NullableIntFieldUpdateOperationsInput | number | null
    Notification?: NotificationUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type ConversationMessageUncheckedUpdateManyWithoutConversationMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversationId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PostLikeCreateManyPostInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
  }

  export type PostCommentCreateManyPostInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
    text: string
  }

  export type PostLikeUpdateWithoutPostInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutPostLikesNestedInput
  }

  export type PostLikeUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type PostCommentUpdateWithoutPostInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutPostCommentNestedInput
    text?: StringFieldUpdateOperationsInput | string
  }

  export type PostCommentUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
  }

  export type PostCommentUncheckedUpdateManyWithoutPostCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateManyFriendshipInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    read?: boolean
    conversationMessageId?: number | null
  }

  export type NotificationUpdateWithoutFriendshipInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    Message?: ConversationMessageUpdateOneWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateWithoutFriendshipInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    conversationMessageId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NotificationUncheckedUpdateManyWithoutNotificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    conversationMessageId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ConversationMessageCreateManyConversationInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: number
  }

  export type ConversationMessageUpdateWithoutConversationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    From?: UserUpdateOneRequiredWithoutConversationMessagesNestedInput
    Notification?: NotificationUpdateManyWithoutMessageNestedInput
  }

  export type ConversationMessageUncheckedUpdateWithoutConversationInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    Notification?: NotificationUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type ConversationMessageUncheckedUpdateManyWithoutMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type NotificationCreateManyMessageInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    read?: boolean
    friendshipId?: number | null
  }

  export type NotificationUpdateWithoutMessageInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    Friendship?: FriendshipUpdateOneWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateWithoutMessageInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    read?: BoolFieldUpdateOperationsInput | boolean
    friendshipId?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}